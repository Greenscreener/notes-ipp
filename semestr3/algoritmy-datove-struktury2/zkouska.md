# Zkouška

## Vyhledávání v textu

- Definice: Terminologie okolo řetězců (podslova, prefixy, suffixy)
	- slovo $\alpha$ … konečná posloupnost znaků z abecedy $\Sigma$
	- prázdný řetězec $\varepsilon$
	- $i$-tý znak $\alpha[i]$ (počítáme od nuly)
	- podřetězec/podslovo $\alpha[i:j]$ (od i-tého znaku do (j-1). znaku včetně)
	- prefix $\alpha[:j]=\alpha[0:j]$
	- suffix $\alpha[i:]=\alpha[i:|\alpha|]$
	- $\alpha[:]=\alpha$
- Algoritmus: Knuth-Morris-Pratt (jedna jehla v seně)
	- udržujeme si informaci o tom, jakým nejdelším prefixem jehly končí zatím přečtená část sena
	- tento prefix postupně zvětšujeme – pokud nejde zvětšit, pomocí zpětné funkce získáme menší prefix jehly a zkusíme zvětšit ten
	- pro získání zpětné funkce stačí postavit vyhledávací automat nad jehlou
		- vrcholy (stavy) = prefixy jehly (od prázdného prefixu $\varepsilon$ k celé jehle)
		- dopředné hrany … spojují prefixy zleva doprava
		- zpětné hrany … odpovídají zpětné funkci (např. z `barba` vede zpětná hrana do `ba`)
	- algoritmus rozdělíme na tři
		- KmpKrok
			- spouštíme pro nově přečtený znak a aktuální stav, vrátí nám nový stav
			- algoritmus projde po zpětných hranách (postupně zkouší kratší a kratší prefixy), dokud nedojde do stavu 0 ($\varepsilon$) nebo nenajde prefix, který pokračuje tím přečteným znakem
			- pokud ten prefix najde, tak stav zvýší o jedna
			- implementační detail: za poslední znak jehly musíme připojit fiktivní znak (takový, který se v seně nevyskytuje)
		- KmpHledej
			- spouštíme pro seno a automat nad jehlou, postupně jsou hlášeny jednotlivé výskyty
			- iterujeme přes všechny znaky sena a spouštíme KmpKrok
			- pokud se stav rovná délce jehly, ohlásíme výskyt
			- časová složitost $\Theta(S)$
				- pro každý znak se prochází nejvýše po jedné dopředné hraně
				- každá zpětná hrana vede aspoň o jeden stav doleva – tedy průchodů po zpětných hranách bude nejvýše tolik, po kolika dopředných hranách jsme prošli
		- KmpKonstrukce
			- nastavíme zpětnou hranu ze stavu 1 do stavu 0
			- provádíme jakoby KmpHledej, akorát jako seno použijeme jehlu bez prvního znaku
			- na základě výsledného stavu z každého kroku algoritmu nastavíme zpětnou hranu
			- časová složitost $\Theta(J)$
	- celkem čas $\Theta(J+S)$
- Algoritmus: Aho-Corasicková (více jehel v seně)
	- automat = trie
		- stavy = prefixy jehel
		- dopředné hrany = přidání jednoho znaku na konec ($\alpha\to\alpha x$)
		- konce jehel (označíme v trii)
		- zpětné hrany – vedou z $\alpha$ do nejdelšího vlastního suffixu $\alpha$, který je stavem (tohle obvykle v trii nebývá)
		- zkratkové hrany – vedou z $\alpha$ do nejbližšího stavu dosažitelného po zpětných hranách, kde končí jehla (použijeme při hlášení výskytů)
	- reprezentace automatu
		- stavy očíslujeme – kořen má číslo 0, ostatní vrcholy libovolná různá
		- pole Dopředu(stav, písmenko) – obsahuje další stav (podle dopředné hrany)
		- pole Slovo(stav) – končí v daném stavu slovo?
		- pole Zpět(stav) – číslo stavu, kam vede zpětná hrana (kromě kořene je vždy právě jedno)
		- pole Zkratka(stav) – číslo stavu, kam vede zkratková hrana
	- algoritmy/procedury
		- AcKrok
			- na vstupu aktuální stav a přečtený znak, na výstupu nový stav
			- projde dopředu po jedné hraně z aktuálního stavu nebo zkouší procházet po zpětných hranách, dokud nebude moct projít dopředu (přinejhorším vrátí kořen)
		- AcHledej
			- na vstupu seno a automat, postupně ohlašuje výskyty
			- spouští AcKrok pro každý znak sena
			- pokud je v daném stavu označen konec jehly, hlásí výskyt
			- prochází po zkratkových hranách a hlásí jednotlivé výskyty
			- složitost $\Theta(S+V)$, kde $S$ je délka sena a $V$ je počet výskytů
		- AcKonstrukce
			- nejdříve sestrojíme trii
			- zpětné hrany můžou vést křížem mezi větvemi stromu
			- proto je konstruujeme po hladinách (BFS, pomocí fronty)
			- pro vrchol $v$ a rodiče $r$ zkusíme k vrcholu Zpět(r) přidat písmeno na hraně $rv$, čímž dostaneme Zpět(v)
			- pokud pokud je Zpět(v) konec jehly, tak Zkratka(v) nastavíme na Zpět(v), jinak nastavíme Zkratka(v) na Zkratka(Zpět(v))
			- algoritmus jakoby hledá všechny jehly (jako u KMP)
			- složitost $\Theta(J)$, kde $J$ je součet délek jednotlivých jehel
	- celkem čas $\Theta(J+S+V)$
- Algoritmus: Rabin-Karp (okénkové hešování)
	- hledání jedné jehly
	- zahashuju si posloupnost $J$ znaků a porovnám s hashem jehly
	- hashovací funkce pro řetězec $x_1\dots x_J$
		- $h(x_1,\dots,x_J)=x_1P^{J-1}+x_2P^{J-2}+\dots+x_JP^0\mod M$
	- postupně přehashovávám pro každý takový úsek sena (hashování v lineárním čase, přehashování v konstantním)
		- $h(x_2,\dots,x_{J+1})=P\cdot h(x_1,\dots,x_j)-x_1 P^J+x_{J+1}\mod M$
	- pokud se hash posloupnosti znaků shoduje s hashem jehly, ověříme, zda je to opravdu jehla
	- průměrná časová složitost $\Theta(J+S+JV+{SJ\over M})$ pro rovnoměrnou hashovací funkci
		- jehlu hashujeme lineárně Hornerovým schématem
		- provádíme $S$ přepočítání hashovací funkce
		- nahlášení každého výskytu trvá $JV$ (ověřujeme, zda je to jehla)
		- pro dvě různé posloupnosti znaků se hashe shodují s pravděpodobností $1/M$ (viz věta o počtu kolizí) – takže průměrně $\Theta({SJ\over M})$ strávíme kontrolou falešně pozitivních výsledků
		- chceme $M\in\Omega(SJ)$, abychom minimalizovali vliv kolizí
	- naše polynomiální hashovací funkce není dokonale rovnoměrná (místo $1/M$ bude pravděpodobnost kolize $J/M$), ale podrobnější analýza nebude zkoušena
- Věta: Počet kolizí u okénkového hešování
	- pro dokonale rovnoměrnou hashovací funkci $1/M$ pro $M$ okének
	- přesnější odhad nebude na zkoušce

## Toky v sítích

- Definice: Síť, tok, přebytek, velikost toku
	- síť je čtveřice
		- orientovaný graf $(V,E)$
			- BÚNO symetrický ($uv\in E\implies vu\in E$)
			- chybějící hrana má jakoby nulovou kapacitu
		- zdroj $z\in V$
		- spotřebič $s\in V,\,s\neq z$
		- kapacity $c:E\to\mathbb R_0^+$
	- tok je funkce $f:E\in\mathbb R_0^+$ taková, že
		- $\forall e\in E:f(e)\leq c(e)$
		- Kirchhoffův zákon
			- zákon zachování, tekutina se nám nikam neztrácí
			- $\forall v\in V\setminus\set{z,s}:f^\Delta(v)=0$
	- pro $v\in V$
		- přítok $f^+(v)\coloneqq \sum_{uv\in E} f(uv)$
		- odtok $f^-(v)\coloneqq \sum_{vw\in E}f(vw)$
		- přebytek $f^\Delta(v)\coloneqq f^+(v)-f^-(v)$
	- velikost toku $|f|\coloneqq f^\Delta(s)$
- Definice: Řez, kapacita řezu
	- $E(A,B)\coloneqq E\cap (A\times B)$
	- tedy $E(A,B)=\set{uv\in E\mid u\in A\land v\in B}$
	- řez je $E(A,B)$ pro $A\subseteq V,\;B=V\setminus A$
		- přičemž $z\in A,\;s\in B$
	- kapacita řezu $c(A,B)\coloneqq \sum_{e\in E(A,B)} c(e)$
	- $f(A,B)\coloneqq \sum_{e\in E(A,B)} f(e)$
	- $f^\Delta(A,B)\coloneqq f(A,B)-f(B,A)$
- Věta: Velikost toku se dá měřit na každém řezu
	- lemma: pro každý řez $E(A,B)$ a každý tok $f$ platí $f^\Delta(A,B)=|f|$
	- důkaz
		- $\sum_{v\in B}f^\Delta(v)=f^\Delta(s)=|f|$
			- podle Kirchhoffova zákona
		- $\sum_{v\in B}f^\Delta(v)=f(A,B)-f(B,A)=f^\Delta(A,B)$
			- hrany zleva doprava přispívají kladně
			- hrany zprava doleva přispívají záporně
			- ostatní hrany nepřispívají
- Definice: Rezerva hrany, nasycená hrana
	- rezerva hrany $uv$
		- $r(uv)\coloneqq c(uv)-f(uv)+f(vu)$
	- hrana je nasycená $\equiv$ má nulovou rezervu
	- hrana je nenasycená $\equiv$ má kladnou rezervu
- Algoritmus: Ford-Fulkerson (zlepšující cesty)
	- cesta je nenasycená $\equiv$ žádná její hrana není nasycená / všechny mají kladné rezervy
	- algoritmus
		- iterujeme, dokud existuje nenasycená cesta ze zdroje do stoku
		- spočítáme rezervu celé cesty (minimum přes rezervy hran cesty)
		- pro každou hranu upravíme tok – v protisměru odečteme co nejvíc, zbytek přičteme po směru
	- pro celočíselné kapacity vrátí celočíselný tok
	- racionální kapacity převedeme na celočíselné
	- pro iracionální kapacity se může rozbít
	- lemma: pokud se algoritmus zastaví, vydá maximální tok
		- algoritmus se zastavil
		- množinu vrcholů, do nichž existuje nenasycená cesta ze zdroje označíme jako $A$, ostatní vrcholy budou v množině $B$
		- všimneme si, že $E(A,B)$ je řez
		- hrany řezu mají zjevně nulovou rezervu
		- po hranách řezu vedoucích z A do B teče tok rovný kapacitě, po hranách z B do A neteče nic
		- nalezli jsme tedy řez $E(A,B)$, pro nějž $f^\Delta(A,B)=c(A,B)$
		- tedy tento řez je minimální a tok $f$ maximální
	- věta: pro každou síť s racionálními kapacitami se Fordův-Fulkersonův algoritmus zastaví a vydá maximální tok a minimální řez
		- vzhledem k operacím, které algoritmus provádí, nemůže z celých čísel vytvořit necelá
	- důsledek: velikost maximálního toku je rovna kapacitě minimálního řezu
	- důsledek: síť s celočíselnými kapacitami má aspoň jeden z maximálních toků celočíselný a Fordův-Fulkersonův algoritmus takový tok najde
- Věta: Minimální řez je stejně velký jako maximální tok
	- pro každý tok $f$ a každý řez $E(A,B)$ platí $|f|\leq c(A,B)$
	- důkaz: $|f|=f^\Delta(A,B)=f(A,B)-f(B,A)\leq f(A,B)\leq c(A,B)$
	- pokud $|f|=c(A,B)$, pak je tok $f$ maximální a řez $E(A,B)$ minimální
	- z analýzy Fordova-Fulkersonova algoritmu plyne, že velikost maximálního toku je rovna kapacitě minimálního řezu
- Definice: Průtok (čistý tok)
	- toku $f$ přiřadíme průtok $f^*$ takto: $f^*(uv)\coloneqq f(uv)-f(vu)$
	- pozorování
		- $f^*(uv)=-f^*(vu)$
		- $f^*(uv)\leq c(uv)$
		- $-c(vu)\leq f^*(uv)$
		- $\forall v\neq z,s:\sum_{uv\in E}f^*(uv)=0$
			- tzn. pro takové $v$ platí $\sum_{uv\in E}f^*(uv)=f^\Delta(v)$
	- lemma: pokud funkce $f^*:E\to\mathbb R$ splňuje tato pozorování, pak existuje tok $f$, jehož průtokem je $f^*$
		- $uv,vu\in E$
		- BÚNO $f^*(uv)\geq 0$
		- $f(uv)\coloneqq f^*(uv)$
		- $f(vu)=0$
	- takže můžeme místo s toky počítat s průtoky, přičemž si to pak ekvivalentně převedeme na toky
- Příklad: Celočíselná síť má celočíselný maximální tok
	- vzhledem k operacím, které Fordův-Fulkersonův algoritmus provádí, nemůže z celých čísel vytvořit necelá
	- z analýzy Fordova-Fulkersonova algoritmu plyne, že síť s celočíselnými kapacitami má aspoň jeden z maximálních toků celočíselný a Fordův-Fulkersonův algoritmus takový tok najde
- Algoritmus: Největší párování v bipartitním grafu
	- z bipartitního grafu vytvoříme síť
		- nalezneme partity grafu, budeme jim říkat levá a pravá
		- hrany zorientujeme zleva doprava
		- přidáme zdroj a vedeme z něj hrany do všech vrcholů levé partity
		- přidáme spotřebič a vedeme do něj hrany ze všech vrcholů pravé partity
		- všem hranám nastavíme jednotkovou kapacitu
	- najdeme maximální celočíselný tok
	- je to párování?
		- kdyby nebylo, dvě hrany by měly společný vrchol
		- z každého vrcholu levé partity může vytékat maximálně jedna jednotka (víc jich nemůže přitéct)
		- podobně pro vrchol pravé partity
		- tedy dvě hrany nemůžou mít společný vrchol
	- je párování největší?
		- z každého toku umíme vytvořit párování, z každého párování umíme vytvořit tok
		- tedy existuje bijekce, ta zachovává velikost
		- největší tok proto musí odpovídat největšímu párování
	- časová složitost
		- úvodní konstrukce v čase $O(n+m)$
		- jedna iterace v čase $O(n+m)$ – nenasycenou cestu najdeme pomocí BFS, tok zlepšíme v čase lineárním s délkou cesty
		- každá iterací zlepší tok aspoň o 1, takže iterací bude nejvýš $n$
		- celkem $O(nm)$
- Definice: Blokující tok, vrstevnatá síť
	- tok $f$ je blokující $\equiv$ pro každou cestu $P$ ze $z$ do $s$ existuje $e\in P$ taková, že $f(e)=c(e)$
	- síť $S$ je vrstevnatá (pročištěná) $\equiv$ každý vrchol i hrana leží na nějaké nejkratší cestě ze $z$ do $s$
- Algoritmus: Dinicův algoritmus (zlepšující toky)
	- k síti $(V,E,z,s,c)$ a toku $f$ v ní je síť rezerv $(V,E,z,s,r)$, kde $r(uv)=c(uv)-f^*(uv)$
	- lemma o zlepšování toků: pro tok $f$ v síti a tok $g$ v odpovídající síti rezerv existuje tok $h$ v původní síti takový, že $|h|=|f|+|g|$ a lze ho najít v čase $O(m)$
		- toky přímo sčítat nemůžeme (mohli bychom se dostat přes kapacitu hrany), ale průtoky ano
	- algoritmus
		- začneme s nulovým tokem $f$
		- opakujeme (tyto kroky tvoří jednu fázi)
			- sestrojíme síť rezerv a smažeme z ní nulové hrany
			- pročistíme síť rezerv (pokud je prázdná, skončíme)
			- najdeme v síti rezerv blokující tok $g$
			- vylepšíme $f$ pomocí $g$
		- vrátíme $f$
	- pročištění sítě rezerv
		- pomocí BFS ze zdroje rozdělíme graf na vrstvy
		- smažeme vrstvy za stokem
		- smažeme hrany, které nevedou o vrstvu vpřed
		- smažeme slepé uličky
			- všechny vrcholy, které nemají odchozí hrany, naházíme do fronty
			- vrcholy ve frontě postupně mažeme
			- pokud jsme přitom vytvořili další vrchol bez odchozích hran, vložíme ho do fronty
			- každý vrchol a každá hrana se účastní nejvýš jednou – v čase $O(m)$
		- čas $O(m)$
	- nalezení blokujícího toku
		- začneme s nulovým tokem $g$
		- dokud existuje $P$ cesta ze $z$ do $s$ v $R$
			- $\varepsilon\leftarrow\min_{e\in P}(r(e)-g(e))$
			- $\forall e\in P: g(e)\leftarrow g(e)+\varepsilon$ a pokud $g(e)=r(e)$, hranu $e$ smažeme
			- dočistíme síť (kdykoliv smažu hranu, musím se zbavit slepých uliček)
		- vrátíme $g$
		- čas $O(nm)$
			- síť je vrstevnatá $\implies$ krok cyklu (bez čistění) v $O(n)$
			- cyklus poběží nejvýše $m$-krát, protože pokaždé smažu alespoň jednu hranu
			- čištění sítě je za všechny iterace $O(m)$
	- lemma: pokud se algoritmus zastaví, vydá maximální tok
		- algoritmus se zastaví, když už neexistuje cesta ze zdroje do stoku po hranách s kladnou rezervou
		- tehdy by se zastavil i Fordův-Fulkersonův algoritmus, který je korektní
	- lemma: během každé fáze vzroste počet vrstev pročištěné sítě aspoň o jedna
		- důsledek: počet fází $\leq n$
		- intuitivní důkaz (zablokovali jsme cesty dané délky) nefunguje – mezi fázemi nám mohly vzrůst rezervy
		- rezerva vzroste těm hranám, které vedou o vrstvu zpět
		- nahlédneme, že žádná cesta, která použije alespoň jednu zpětnou hranu nemůže být krátká
			- nově vzniklá cesta bude mít aspoň o 2 větší délku než nejkratší cesty
	- fáze trvá $O(nm)$, takže Dinicův algoritmus najde maximální tok v čase $O(n^2m)$
- Definice: Vlna, převedení přebytku po hraně
	- $f$ je vlna $\equiv$
		- $\forall e\in E:f(e)\leq c(e)$
		- $\forall v\neq z,s: f^\Delta(v)\geq 0$
	- převedení přebytku
		- $f^\Delta(u)\gt 0$
		- $r(uv)\gt 0$
		- $\delta\coloneqq \min(f^\Delta(u),r(uv))$
		- $f'(uv)\coloneqq f(uv)+\delta$
		- důsledky
			- $f$ zůstane vlnou
			- $f^\Delta(u)\mathrel{-}=\delta,\;f^\Delta(v)\mathrel{+}=\delta$
			- $r(uv)\mathrel{-}=\delta,\;r(vu)\mathrel{+}=\delta$
- Algoritmus: Goldbergův algoritmus (výšky a přebytky)
	- výška $h:V\to\mathbb N$
	- algoritmus
		- nastavíme počáteční výšky – zdroji nastavíme výšku $n$, ostatním vrcholům 0
		- vytvoříme počáteční vlnu – $f$ je všude nulová kromě hran ze zdroje, ty nastavíme na maximum (tedy nechť se $f$ rovná jejich kapacitě)
		- dokud existuje vrchol $u\neq z,s$, který má $f^\Delta(u)\gt 0:$
			- pokud může přebytek někam „stéct“ (existuje hrana $uv$ s nenulovou rezervou a $u$ je výš než $v$), převedeme přebytek po $uv$
			- pokud přebytek nemůže nikam stéct, zvedneme $u$ o 1
	- invariant A (základní)
		- $f$ je vlna
		- výška vrcholů neklesá
		- výška zdroje a stoku se nemění
		- přebytek ve všech vrcholech kromě zdroje je větší roven 0
	- invariant S (o spádu)
		- neexistuje hrana s nenulovou rezervou, která by vedla o více než jednu úroveň dolů
			- na začátku to platí
			- rozbít se to můžu zvednutím (to se nestane – místo toho se provede převedení) nebo převedením (ale to zvyšuje rezervu jenom do kopce – takže se to taky nemůže stát)
	- lemma K (o korektnosti)
		- pokud se algoritmus zastaví, finální $f$ je maximální tok
			- $f$ je tok
			- $f$ je maximální
			- kdyby nebyl maximální, pak podle Fordova-Fulkersonova algoritmu existuje nenasycená cesta ze zdroje do spotřebiče
			- zdroj je ve výšce $n$, spotřebič ve výšce 0, délka cesty je maximálně $n-1$, tudíž tam bude hrana se spádem aspoň dva, která ale na nenasycené cestě nemůže existovat
	- invariant C (cesta do zdroje)
		- mějme vrchol, jehož přebytek je kladný
		- pak existuje nenasycená cesta z tohoto vrcholu do zdroje
		- důkaz
			- $A:=\set{t\in V\mid\exists\text{ nenasycená cesta }v\to t}$
			- chceme ukázat $z\in A$
			- $\sum_{a\in A}f^\Delta(a)=\underbrace{f(\overline A,A)}_{0}-\underbrace{f(A,\overline A)}_{\geq 0}$
				- $f(\overline A,A)=0$, protože jinak by existovala nenasycená cesta $v\to x$, kde $x$ je nějaký vrchol v $\overline A$, což by byl spor
			- tudíž suma je nekladná
			- ale v sumě je aspoň jeden prvek kladný
			- takže tam musí být záporný člen – to je pouze zdroj
	- invariant V (o výšce)
		- $\forall v: h(v)\leq 2n$
		- invariant C $\implies$ invariant V
			- uvažme první porušení – zvedáme $v\in V$ z výšky $2n$
			- tehdy $f^\Delta(v)\gt 0\implies\exists P$ nenasycená cesta $v\to z$
				- $z$ ve výšce $n$, $v$ ve výšce $2n$, umíme dostat spor podobně jako v důkazu lemmatu K
	- lemma Z (zvednutí)
		- počet zvednutí je nejvýš $2n^2$
		- protože každý z $n$ vrcholů vystoupá nejvýše do výšky $2n$ (z invariantu V)
	- lemma S (sytá převedení)
		- převedení je nasycené (syté) $\equiv$ vynuluje rezervu
		- pozorování: nenasycené převedení po hraně $uv$ vynuluje $f^\Delta(u)$
		- lemma: počet sytých převedení $\leq n\cdot m$
		- důkaz
			- uvažme hranu $uv$
			- těsně po sytém převedení je $r(uv)=0$ a $uv$ vede z kopce
			- před dalším sytým převedení $r(uv)\gt 0$
			- mezitím se muselo převést v protisměru … tedy $uv$ do kopce
			- tzn. posloupnost
				- syté převedení u→v
				- aspoň 2 zvednutí $v$
				- převedení v→u
				- aspoň 2 zvednutí $u$
				- až pak může přijít další syté převedení u→v
			- podle invariantu V toto max. $n$-krát
	- potenciál $\Phi$ definujeme jako součet výšek vrcholů různých od zdroje a stoku, které mají kladný přebytek
		- na počátku je nulový
		- zvednutí ho zvýší o 1
			- celkem $\leq 2n^2$
		- syté převedení po hraně $uv$ ho možná sníží o $h(u)$ a možná zvýší o $h(v)$, takže se $\Phi$ zvýší nejvýš o $2n$
			- celkem $\leq 2n^2m$
		- nenasycené převedení po hraně $uv$ o určitě sníží o $h(u)$ a možná ho zvýší o $h(v)$, přičemž $h(u)=h(v)+1$, takže se $\Phi$ sníží aspoň o 1
	- lemma N (nenasycená převedení)
		- počet nenasycených převedení $\in O(n^2m)$
		- rozbor viz potenciál (snižovat o 1 můžeme nejvýš tolikrát, kolikrát jsme zvyšovali o 1)
	- implementace
		- seznam vrcholů s kladným přebytkem
			- údržba v $O(1)$ při změně přebytku
			- nalezení nějakého vrcholu s kladným přebytkem v $O(1)$
		- pro každý vrchol seznam hran s kladnou rezervou, které z něj vedou z kopce
			- převedení v $O(1)$
			- zvednutí vrcholu v $O(n)$
	- složitost
		- inicializace v čase $O(m)$
		- $\leq 2n^2$ zvedání v $O(n)$
		- $\leq mn$ sytých převedení v $O(1)$
		- $O(n^2m)$ nenasycených převedení v $O(1)$
		- celkem čas $O(n^2m)$
- Algoritmus: Goldbergův algoritmus s výběrem nejvyššího vrcholu
	- rozšíření původního Goldbergova algoritmu
	- lemma N'
		- když vybereme vždy nejvyšší $v$ s kladným přebytkem, tak nastane $O(n^3)$ nenasycených převedení
	- důkaz
		- $H$ … výška nejvyššího vrcholu s kladným přebytkem
		- fáze končí změnou $H$
			- zvýšení zvednutím
				- max. $2n^2$-krát
				- $H$ vždy roste o 1
			- snížení aspoň o 1
				- max. $2n^2$-krát (klesá právě tolikrát, kolikrát roste)
	- pozorování: během jedné fáze se každý vrchol účastní maximálně jednoho nenasyceného převedení
		- nenasycené převedení vynuluje přebytek
		- převádí se z kopce → nemůže se zvýšit jeho přebytek
	- tudíž během fáze je všech nenasycených převedení nejvýš $n$
	- fází je $O(n^2)$, takže složitost algoritmu je $O(n^3)$
		- odhad není optimální, lze ukázat $O(n^2\sqrt m)$

## Algebraické algoritmy

- Věta: Reprezentace polynomu grafem
	- graf … vyhodnocení polynomu v několika bodech (vektor)
		- mějme pevné $x_0,\dots,x_{n-1}$
		- mějme polynom $P$ stupně $n-1$ (tedy velikosti $n$)
		- jeho graf je vektor $(P(x_0),\dots,P(x_{n-1}))$
	- věta
		- buďte $P,Q$ polynomy stupně nejvýše $d$
		- pokud platí $P(x_i)=Q(x_i)$ pro navzájem různá čísla $x_0,\dots,x_d$, pak $P$ a $Q$ jsou identické
			- tedy polynom stupně $d$ je určený $d+1$ body
	- lemma (důkaz případně v Průvodci): pro polynom $P$ stupně $d\geq 0$ je počet $x$ takových, že $P(x)=0$, nejvýše $d$
	- důkaz věty
		- $R(x)\coloneqq P(x)-Q(x)$
		- $\forall j: R(x_j)=P(x_j)-Q(x_j)=0$
		- stupeň $R\leq d$
		- podle lemmatu $R\equiv 0$, takže $P\equiv Q$
			- kdyby byl $d\geq 0$, tak by to byl spor s lemmatem, protože se $R(x)$ rovná nule v $d+1$ bodech $\implies d=-1\implies R\equiv 0$
- Definice: Primitivní n-tá odmocnina z jedničky
	- komplexní číslo $x$ je primitivní $n$-tá odmocnina z 1, pokud $x^n=1$ a žádné z čísel $x^1,x^2,\dots,x^{n-1}$ není rovno 1
- Věta: Rychlá Fourierova transformace a její inverze
- Věta: Násobení polynomů pomocí Fourierovy transformace

## Paralelní algoritmy

- Definice: Hradlová síť
- Algoritmus: Sčítání přirozených čísel hradlovou sítí
- Algoritmus: Násobení přirozených čísel hradlovou sítí
- Definice: Komparátorová síť
- Algoritmus: Bitonické třídění komparátorovou sítí

## Geometrické algoritmy

- Algoritmus: Konvexní obal
- Algoritmus: Průsečíky úseček
- Definice: Voroného diagram
- Algoritmus: Lokalizace bodu v mnohoúhelníkové síti
- Algoritmus: Semipersistentní binární vyhledávací strom

## Převody problémů

- Definice: Rozhodovací problém
- Příklad: Bipartitní párování jako rozhodovací problém, kódování vstupu
- Definice: Převod mezi problémy
- Věta: Vlastnosti převoditelnosti (reflexivita, tranzitivita apod.)
- Definice: Problémy: klika, nezávislá množina, SAT, 3-SAT, 3,3-SAT, 3D-párování
- Algoritmus: Převod klika ↔ nezávislá množina
- Algoritmus: Převod SAT → 3-SAT → 3,3-SAT
- Algoritmus: Převod 3-SAT → nezávislá množina
- Algoritmus: Převod nezávislá množina → SAT
- Algoritmus: Převod 3,3-SAT → 3D-párování

## NP-úplnost

- Definice: Třídy složitosti P a NP
- Definice: NP-těžké a NP-úplné problémy
- Věta: Pokud A→B a B∈P, pak A∈P
- Věta: Pokud A→B, B∈NP a A je NP-úplný, pak B je NP-úplný
- Věta: Cookova věta: SAT je NP-úplný (náznak důkazu)
- Algoritmus: Převod obvodového SATu na SAT
- Příklad: Klasické NP-úplné problémy

## Jak zvládnout těžký problém

- Algoritmus: Nezávislá množina ve stromu
- Algoritmus: Barvení intervalového grafu
- Algoritmus: Pseudopolynomiální algoritmus pro problém batohu
- Definice: Aproximační algoritmus
- Algoritmus: 2-aproximace obchodního cestujícího v metrickém prostoru
- Věta: Neaproximovatelnost obchodního cestujícího bez trojúhelníkové nerovnosti
- Definice: Polynomiální aproximační schéma (PTAS)
- Definice: Plně polynomiální aproximační schéma (FPTAS)
- Algoritmus: FPTAS pro problém batohu
