# Algoritmy a datové struktury 2

## Hledání v řetězci

- značení
	- jehla $\iota$
		- $J=|\iota|$
	- seno $\sigma$
		- $S=|\sigma|$
	- abeceda $\Sigma$
		- předpokládáme konečnost a malou konstantní velikost
	- slova/řetězce $\alpha,\beta,\gamma,\dots$
	- znaky $a,b,c\dots$
	- délka řetězce $|\alpha|$
	- prázdný řetězec $\varepsilon$
		- $|\varepsilon|=0$
	- zřetězení $\alpha\beta$
	- i-tý znak $\alpha[i]$ (počítáme od nuly)
	- podřetězec $\alpha[i:j]$ (od i-tého znaku do (j-1). znaku včetně)
	- prefix $\alpha[:j]=\alpha[0:j]$
	- suffix $\alpha[i:]=\alpha[i:|\alpha|]$
	- $\alpha[:]=\alpha$
- pozorování
	- prázdný řetězec je prefixem i suffixem jakéhokoliv řetězce
	- každý řetězec je prefixem i suffixem sebe sama
	- každý podřetězec se dá zapsat jako prefix nějakého suffixu nebo suffix nějakého prefixu
- jak najít jehlu
	- můžeme hledat jehlu na každém indexu sena → $\Theta(J\cdot S)$
	- můžeme po nenalezení přeskočit dál → nefunguje, viz seno "clanekokokosu", jehla "kokos"
	- postupně si vytváříme seno
		- df: stav algoritmu := nejdelší prefix jehly, který je suffixem sena
		- …
- hledání více jehel v kupce sena – algoritmus Aho-Corasicková
	- automat = trie
		- stavy = prefixy jehel
		- dopředné hrany = přidání jednoho znaku na konec ($\alpha\to\alpha x$)
		- konce jehel (označíme v trii)
		- zpětné hrany – vedou z $\alpha$ do nejdelšího vlastního suffixu $\alpha$, který je stavem (tohle obvykle v trii nebývá)
		- zkratkové hrany – vedou z $\alpha$ do nejbližšího stavu dosažitelného po zpětných hranách, kde končí jehla
	- reprezentace automatu
		- stavy očíslujeme – kořen má číslo 0, ostatní vrcholy libovolná různá
		- pole Dopředu(stav, písmenko) – obsahuje další stav (podle dopředné hrany)
		- pole Slovo(stav) – končí v daném stavu slovo?
		- pole Zpět(stav) – číslo stavu, kam vede zpětná hrana (kromě kořene je vždy právě jedno)
		- pole Zkratka(stav) – číslo stavu, kam vede zkratková hrana
	- algoritmus
		- …
- Robinův-Karpův algoritmus
	- hledání jedné jehly (?)
	- zahashuju si posloupnost $J$ znaků a porovnám s hashem jehly
	- postupně přehashovávám pro každý takový úsek sena (hashování v lineárním čase, přehashování v konstantním)
	- průměrná časová složitost $\Theta(J+S+JV+{SJ\over M})$ pro rovnoměrnou hashovací funkci
	- přesnější odhad nebude na zkoušce

## Toky v síti

- graf
- máme zdroj a spotřebič (vrcholy)
- trubky (hrany) mají kapacitu (ohodnocení)
- trubky jsou orientované
- df: síť je čtveřice
	- orientovaný graf $(V,E)$
		- BÚNO symetrický ($uv\in E\implies vu\in E$)
		- chybějící hrana má jakoby nulovou kapacitu
	- zdroj $z\in V$
	- spotřebič $s\in V,\,s\neq z$
	- kapacity $c:E\to\mathbb R_0^+$
- df: tok je funkce $f:E\in\mathbb R_0^+$ taková, že
	- $\forall e\in E:f(e)\leq c(e)$
	- Kirchhoffův zákon (zákon zachování, tekutina se nám nikam neztrácí) … $\forall v\in V,\,v\neq z,s:f^\Delta(v)=0$
- df: pro $v\in V$
	- přítok $f^+(v):=\sum_{uv\in E} f(uv)$
	- odtok $f^-(v):=\sum_{vw\in E}f(vw)$
	- přebytek $f^\Delta(v):=f^+(v)-f^-(v)$
- df: velikost toku $|f|:=f^\Delta(s)$
- pozorování: $f^\Delta(s)=-f^\Delta(z)$
- …
- df: toku $f$ přiřadíme průtok $f^*$
	- $f^*(uv):=f(uv)-f(vu)$
	- pozorování
		- $f^*(uv)=-f^*(vu)$
		- $f^*(uv)\leq c(uv)$
		- $-c(vu)\leq f^*(uv)$
		- $\forall v\neq z,s:\sum_{uv\in E}f^*(uv)=0$
			- tzn. pro takové $v$ platí $\sum_{uv\in E}f^*(uv)=f^\Delta(v)$
	- $r(uv):=c(uv)-f(uv)+f(vu)=c(uv)-f^*(uv)$
- lemma: pokud funkce $f^*:E\to\mathbb R$ splňuje tato pozorování, pak existuje tok $f$, jehož průtokem je $f^*$
- důkaz
	- $uv,vu\in E$
	- BÚNO $f^*(uv)\geq 0$
	- $f(uv):=f^*(uv)$
	- $f(vu)=0$
- takže můžeme místo s toky počítat s průtoky, přičemž si to pak ekvivalentně převedeme na toky
- df: k síti $(V,E,z,s,c)$ a toku $f$ v ní je síť rezerv $(V,E,z,s,r)$, kde $r=c-f^*$
- lemma: pro každý tok $f$ v síti $S$ a každý tok $g$ v síti $R(S,f)$ existuje tok $h$ v síti $S$ takový, že $|h|=|f|+|g|$ a $h$ lze najít v čase $O(m)$
	- $m$ … počet hran
- důkaz: $h^*:=f^*+g^*$
	- $h^*(uv)=f^*(uv)+g^*(uv)$
	- $g^*(uv)\leq r(uv)\leq c(uv)-f^*(uv)$
	- …
- df: tok $f$ je blokující $\equiv$ pro každou cestu $P$ ze $z$ do $s$ existuje $e\in P$ taková, že $f(e)=c(e)$
- df: síť $S$ je vrstevnatá (pročištěná) $\equiv$ každý vrchol i hrana leží na nějaké nejkratší cestě ze $z$ do $s$
- Dinicův algoritmus $O(n^2m)$
	- $f\leftarrow$ všude nulový tok
	- opakujeme (tyto kroky tvoří jednu fázi)
		- $R\leftarrow$ síť rezerv vzhledem k $f$
		- smažeme z $R$ nulové hrany
		- pročistíme $R$
			- pokud $R=\emptyset$, skončíme
		- $g\leftarrow$ blokující tok v $R$
		- vylepšíme $f$ pomocí $g$
	- vrátíme $f$
- čištění sítě $O(m)$
	- pomocí BFS ze $z$ rozdělíme graf na vrstvy
	- smažeme vrstvy za $s$
	- smažeme hrany, které nevedou o vrstvu vpřed (tzn. ty, které vedou o vrstvu zpět a které vedou uvnitř vrstvy)
	- smažeme slepé uličky (pomocí fronty)
		- každý vrchol a každá hrana se účastní nejvýš jednou
- blokující tok $O(nm)$
	- $g\leftarrow 0$ (tok, který je všude nulový)
	- dokud existuje $P$ cesta ze $z$ do $s$ v $R$
		- $\varepsilon\leftarrow\min_{e\in P}(r(e)-g(e))$
		- $\forall e\in P: g(e)\leftarrow g(e)+\varepsilon$ a pokud $g(e)=r(e)$, hranu $e$ smažeme
		- dočistíme síť (kdykoliv smažu hranu, musím se zbavit slepých uliček)
	- vrátíme $g$
	- složitost
		- krok cyklu (bez čistění) v $O(n)$, cyklus poběží nejvýše $m$-krát, protože pokaždé smažu alespoň jednu hranu
		- čištění sítě je za všechny iterace $O(m)$
- lemma: během každé fáze vzroste počet vrstev pročištěné sítě aspoň o jedna
	- důsledek: počet fází $\leq n$
	- intuitivní důkaz (zablokovali jsme cesty dané délky) nefunguje – mezi fázemi nám mohly vzrůst rezervy
	- rezerva vzroste těm hranám, které vedou o vrstvu zpět
	- nahlédneme, že žádná cesta, která použije alespoň jednu zpětnou hranu nemůže být krátká
		- nově vzniklá cesta bude mít aspoň o 2 větší délku než nejkratší cesty
- df: $f$ je vlna $\equiv$
	- $\forall e\in E:f(e)\leq c(e)$
	- $\forall v\neq z,s: f^\Delta(v)\geq 0$
- převedení přebytku
	- $f^\Delta(u)\gt 0$
	- $r(uv)\gt 0$
	- $\delta:=\min(f^\Delta(u),r(uv))$
	- $f'(uv):=f(uv)+\delta$
	- důsledky
		- $f$ zůstane vlnou
		- $f^\Delta(u)\mathrel{-}=\delta,\;f^\Delta(v)\mathrel{+}=\delta$
		- $r(uv)\mathrel{-}=\delta,\;r(vu)\mathrel{+}=\delta$
- výška $h:V\to\mathbb N$
- Goldbergův algoritmus
	- $f(\_)\leftarrow0$
	- $\forall zv\in E: f(zv)\leftarrow c(zv)$
	- $h(\_)\leftarrow 0,\;h(z)\leftarrow n$
	- dokud $\exists v\neq z,s:f^\Delta(v)\gt 0$
		- pokud $\exists vw\in E:r(vw)\gt 0\land h(v)\gt h(w)$
			- převedeme po $vw$
		- jinak $h(v)\leftarrow h(v)+1$
- vlna: $f:E\to\mathbb R_0^+$
	- $f\leq c,\,\forall v\neq z,s:f^\Delta(v)\geq 0$
- převedení po hraně $uv$
	- když $f^\Delta(u)\gt 0,\,r(uv)\gt 0$
		- $h(u)\gt h(v)$
	- tak na hraně $uv$ zvýšíme o $\delta :=\min(r(uv),f^\Delta(u))$
- invariant A (základní)
	- $f$ je vlna
	- $\forall v: h(v)$ neklesá
	- $h(z)=n,\, h(s)=0$
	- $\forall v\neq z:f^\Delta(v)\geq 0$
- invariant S (o spádu)
	- $\nexists uv\in E:r(uv)\gt 0\land h(u)\gt h(v)+1$
		- na začátku platí
		- rozbít se to můžu zvednutím (to se nestane – místo toho se provede převedení) nebo převedením (ale to zvyšuje rezervu jenom do kopce – takže se to taky nemůže stát)
- lemma K (korektnosti)
	- pokud se algoritmus zastaví, finální $f$ je maximální tok
- důkaz
	- $f$ je tok
	- $f$ je maximální
	- kdyby nebyl maximální → podle FF existuje nenasycená cesta ze zdroje do spotřebiče
	- zdroj je ve výšce $n$, spotřebič ve výšce 0, délka cesty je maximálně $n-1$, tudíž tam bude hrana se spádem aspoň dva, která ale na nenasycené cestě nemůže existovat
- invariant C (cesta do zdroje)
	- $\forall v:f^\Delta(v)\gt 0$
	- $\exists P$ nenasycená cesta z $v$ do $z$
	- důkaz
		- $A:=\set{t\in V\mid\exists\text{ nenasycená cesta }v\to t}$
		- chceme ukázat $z\in A$
		- $\sum_{a\in A}f^\Delta(a)=\underbrace{f(\overline A,A)}_{0}-\underbrace{f(A,\overline A)}_{\geq 0}$
		- tudíž suma je nekladná
		- ale v sumě je aspoň jeden prvek kladný
		- takže tam musí být záporný člen – to je pouze zdroj
- invariant V (o výšce)
	- $\forall v: h(v)\geq 2n$
	- invariant C $\implies$ invariant V
		- uvažme první porušení – zvedáme $v\in V$ z výšky $2n$
		- tehdy $f^\Delta(v)\gt 0\implies\exists P$ nenasycená cesta $v\to z$
			- $z$ ve výšce $n$, $v$ ve výšce $2n$, umíme dostat spor podobně jako v důkazu lemmatu K
- lemma Z (zvednutí)
	- počet zvednutí je nejvýš $2n^2$
	- protože každý z $n$ vrcholů vystoupá nejvýše do výšky $2n$ (z invariantu V)
- df: převedení je nasycené $\equiv$ vynuluje rezervu
- pozorování: nenasycené převedení po hraně $uv$ vynuluje $f^\Delta(u)$
- lemma S („sytá“ převedení)
	- počet nasycených převedení $\leq n\cdot m$
- důkaz
	- uvažme hranu $uv$
	- těsně po sytém převedení je $r(uv)=0$ a $uv$ vede z kopce
	- před dalším sytým převedení $r(uv)\gt 0$
	- mezitím se muselo převést v protisměru … tedy $uv$ do kopce
	- tzn. posloupnost
		- syté převedení u→v
		- aspoň 2 zvednutí $v$
		- převedení v→u
		- aspoň 2 zvednutí $u$
		- až pak může přijít další syté převedení u→v
	- podle invariantu V toto max. $n$-krát
- df: potenciál $\Phi:=\sum_{v\neq z,s:f^\Delta(v)\gt0}h(v)$
	- $\Phi\geq 0$
	- na počátku $\Phi=0$
	- zvednutí: zvýší $\Phi$ o 1
		- celkem $\leq 2n^2$
	- sytá převedení po hraně $uv$: změní možná o $-h(u)$ a možná o $+h(v)$, takže se $\Phi$ zvýší nejvýš o $2n$
		- celkem $\leq 2n^2m$
	- nenasycená převedení po hraně $uv$: určitě změní o $-h(u)$ a možná o $+h(v)$, přičemž $h(u)=h(v)+1$, takže se $\Phi$ sníží aspoň o 1
- lemma N (nenasycená převedení)
	- počet nenasycených převedení $\in O(n^2m)$
- implementace
	- $S:=$ seznam vrcholů s přebytkem
		- údržba O(1) při změně přebytku
		- výběr v kroku 3 v algoritmu … v O(1)
	- $\forall v:K(v):=$ seznam hran s nenulovou rezervou, které z vrcholu $v$ vedou z kopce
		- převedení po $uv$ … O(1)
		- zvednutí $u$ … O(n)
- rozbor složitosti
	- inicializace v čase $O(m)$
	- čas celkem $O(2n^2\cdot n+nm\cdot 1+n^2m\cdot 1)=O(n^2m)$
- **vylepšení Goldbergova algoritmu**
- lemma N'
	- v algoritmu s výběrem nejvyššího $v$ s $f^\Delta(v)\gt 0$ nastane $O(n^3)$ nenasycených převedení
- důkaz
	- $H:=\max\set{h(x)\mid f^\Delta(v)\gt 0,\;v\neq z,s}$
	- fáze končí změnou $H$
		- zvýšení zvednutím
			- max. $2n^2$-krát
			- $H$ vždy roste o 1
		- snížení aspoň o 1
			- max. $2n^2$-krát (klesá právě tolikrát, kolikrát roste)
	- pozorování: během jedné fáze se každý vrchol účastní maximálně jednoho nenasyceného převedení
		- nenasycené převedení vynuluje přebytek
		- převádí se z kopce → nemůže se zvýšit jeho přebytek
	- tudíž během fáze je všech nenasycených převedení nejvýš $n$
	- fází je $O(n^2)$, takže složitost algoritmus je $O(n^3)$
		- odhad není optimální, lze ukázat $O(n^2\sqrt m)$

## Rychlá Fourierova transformace

- $P(x) := \sum_{j=0}^{n-1} p_jx^j$
- $\vec{p}=(p_0,p_1,\dots,p_{n-1})$
- $n$ … velikost polynomu
- normalizace: $p_{n-1}\neq 0$ nebo $n=0$
- $(n-1)$ … stupeň polynomu
- násobení polynomů
	- $R=P\cdot Q$
	- …
	- konvoluce vektorů (získání koeficientu $r_t$) … $\Theta(n)$
	- násobení vektorů (získání všech koeficientů $r_*$) … $\Theta(n^2)$
- rovnost polynomů – dvě možnosti
	- identita $P\equiv Q$ – stejné vektory koeficientů po normalizaci
	- rovnost funkcí – $\forall x:P(x)=Q(x)$
	- identita $\implies$ rovnost funkcí … jednoduchá
	- identita $\impliedby$ rovnost funkcí … podle věty
- věta: nechť $P,Q$ jsou polynomy stupně maximálně $d$ a $P(x_j)=Q(x_j)$ pro navzájem různá čísla $x_0,\dots,x_d$, potom $P\equiv Q$
	- polynom stupně $d$ je určený $d+1$ body
- lemma: pro polynom $P$ stupně $d\geq 0$ je počet $x$ takových, že $P(x)=0$ nejvýše $d$
- dk:
	- $R:=P-Q$
	- $\forall j: R(x_j)=P(x_j)-Q(x_j)=0$
	- stupeň $R\leq d$
	- podle lemmatu $R\equiv 0$, takže $P\equiv Q$
		- kdyby byl $d\geq 0$, tak by to byl spor s lemmatem, protože se $R(x)$ rovná nule v $d+1$ bodech → $d=-1$ → $R\equiv 0$
- graf polynomu
	- …
- násobení polynomů a grafy
	- …
	- postřehy
		- násobením polynomů dostaneme polynom s dvojnásobným stupněm, takže řekneme, že u násobených polynomů je horních $\frac n2$ koeficientů nulových
- teorie ke komplexním číslům
	- …
	- df: $\omega\in\mathbb C$ je primitivní $n$-tá odmocnina z 1 $\equiv\omega^n=1$ a $\omega^1,\dots,\omega^{n-1}\neq 1$
	- pozorování: $\omega^j\neq\omega^k$ pro $0\leq j\lt k\lt n$
		- kdyby $\omega^j=\omega^k$, pak $\underbrace{\omega^k\over\omega^j}_{\omega^{k-j}}=1$, což je spor
	- pozorování: pro sudé $n$ … $\omega^{n/2}=-1$
		- protože kroužím od $1$ k $1$
	- pro $|x|=1:x^{-1}=\overline x$
	- pozorování: $\omega^2$ je primitivní $n/2$-tá odmocnina z 1
- algoritmus FFT
	- vstup
		- $n=2^k$
		- $\omega$ … primitivní $n$-tá odmocnina z 1
		- $(p_0,\dots,p_{n-1})$ … koeficienty polynomu
	- výstup
		- $(y_0,\dots,y_{n-1})$ … graf polynomu $P$ v bodech $(\omega^0,\dots,\omega^{n-1})$
	- algoritmus
		- …
- inverzní Fourierovu transformaci můžeme počítat jako tu dopřednou, jen vydělením $n$
- celé násobení polynomů umíme v čase $\Theta(n\log n)$
- $\Omega_{jk}=\omega^{jk}$
- lemma: $\Omega^{-1}=\frac 1n\cdot\overline{\Omega}$
- důkaz
- poznámka k FFT – dá se implementovat nerekurzivně; lze nahlédnout, že tam vzniká permutace odpovídající seřazení binárních čísel pozpátku
- věta: nechť $x\in\mathbb R^n$ a $y=\mathcal F(x)$; potom $y_j=\overline{y_{n-j}}$ pro všechna $j$
- tím pádem můžeme každý reálný vektor zapsat jako lineární kombinaci navzorkovaných sinů a kosinů

## Paralelní algoritmy

- hradlo arity $k$ má $k$ vstupů a jeden výstup
- počítá funkci $f:\Sigma^k\to\Sigma$
- $\Sigma$ … konečná abeceda, typicky $\set{0,1}$
- booleovská hradla
	- binární: AND, OR, XOR, $\leq$ (implikace), … (je jich 16)
	- unární: NOT (a „buffer“)
	- nulární, konstanty: 0, 1
- $\text{Majorita}(x, y, z)=(x\land y)\lor(x\land z)\lor(y\land z)$
- hradlová síť obsahuje
	- hradla
	- vstupní porty
	- výstupní porty
	- acyklické propojení
- výpočet probíhá v taktech
	- 0. takt: ohodnotíme vstupní porty a konstanty
	- $(i+1).$ takt: ohodnotíme hradla a porty, jejichž vstupy byly ohodnoceny nejpozději v $i.$ taktu
- tak dostáváme rozklad sítě na vrstvy, kde v $i$-té vrstvě jsou hradla a porty, které byly ohodnoceny v $i.$ taktu
- čas = počet vrstev
- prostor = počet hradel
	- nemohli bychom použít počet hradel v největší vrstvě, protože ne všechny hrany vedou o jednu vrstvu (někdy je potřeba, aby si hradlo pamatovalo svůj výsledek během několika taktů)
- je nutné omezit počet vstupů a výstupů – jinak bychom mohli cokoliv počítat v konstantním čase
- kombinační obvody … na obecné abecedě $\Sigma$
- booleovské obvody … $\Sigma=\set{0,1}$
- hradlová síť má pevnou velikost vstupu
- tedy ekvivalent programu ve světě hradlových sítí by byla sada různých hradlových sítí pro různé velikosti vstupu
	- tedy výpočetní model je neuniformní
- chceme tyto sítě efektivně generovat – ale stačí nám polynomiální čas
- co se týče časové složitosti hradlových sítí – obvykle chceme polylogaritmickou složitost (tedy nějakou mocninu logaritmu)
- $\text{OR}(x_1,\dots,x_n)$
	- lze v lineárním čase – vždycky vezmeme výsledek a přiORujeme $x_i$
	- nebo v logaritmickém čase – ORujeme po dvojicích
		- $\Theta(\log n)$ vrstev
		- $\Theta(n)$ hradel
- binární sčítání
	- $z_i=x_i\oplus y_i\oplus c_i$
		- kde $\oplus$ je XOR
	- $c_{i+1}=\text{Majorita}(x_i,y_i,c_i)$
	- jednoduchá implementace má $\Theta(n)$ hladin a $\Theta(n)$ hradel – musíme čekat na přenosy ($c_i$)
	- jak předpovídat přenosy?
	- blok – souvislá posloupnost bitů
	- chování bloku – závislost $c_\text{out}$ na $c_{\text{in}}$
	- fáze (ručního?) výpočtu
		- chování kanonických bloků
		- zahušťuji přenosy
		- finální XORy (jedna vrstva)
- binární násobení
	- pomocí ANDu a bitového posunu v $O(1)$ dostaneme $n$ mezivýsledků, ty chceme sčítat
	- kdybychom sčítali po dvojicích, dostali bychom se na $O(\log^2n)$
	- ale my ke sčítání použijeme kompresor – ze 3 sčítanců uděláme dva
		- v první vrstvě $n$ čísel, v druhé $\frac 23 n$ čísel, ve třetí $(\frac 23)^2 n$ čísel, …, v poslední 2 čísla, ty sečteme klasickou sčítačkou
		- kompresorových vrstev bude $O(\log n)$, hloubka kompresoru je $O(1)$
		- závěrečná sčítačka bude $O(\log n)$
	- takže celková složitost násobení bude $O(\log n)$
	- v reálných počítačích se používá hradlová síť založena na Fourierově transformaci, protože má menší prostorovou složitost
- komparátorová síť
	- má $n$ vstupů a $n$ výstupů
	- výstupem je setříděná posloupnost vstupních dat
	- mezi vrstvami se vždy převádí permutace vstupu – BÚNO výstupy se nevětví
	- bubble sort lze paralelizovat v $\Theta(n)$ vrstvách
- df: posloupnost $x_0,\dots,x_{n-1}$ je
	- čistě bitonická $\equiv\exists k:x_0\lt x_1\lt \dots\lt x_k\gt \dots\gt x_{n-1}$
	- bitonická $\equiv$ má čistě bitonickou rotaci
		- tedy $\exists l: x_l,x_{l+1},\dots,x_{l+n-1}$ (kde indexy jsou modulo $n$) je čistě bitonická
- separátor $S_n$
	- na vstupu bitonická posloupnost
	- na výstupu dvě poloviční bitonické posloupnosti, kde všechny prvky jedné jsou menší než všechny prvky druhé
	- princip
		- rozdělím vstup na poloviny
		- nainstaluju komparátory mezi $i$-tým prvkem v první polovině a $i$-tým prvkem v druhé polovině (takže vlastně $x_i$ a $x_{n/2+i}$)
		- prvky rozdělím na horu ($n/2$ největších prvků) a údolí ($n/2$ nejmenších prvků)
		- hora i údolí jsou souvislé
		- $x_k$ … prvek, kterým začíná hora
		- $x_{k+n/2}$ … prvek, kterým končí hora
		- $k$ je BÚNO menší než $n/2$
		- jak fungují komparátory?
			- pro $i\lt k$ neprohazujeme
			- pro $i\geq k$ prohazujeme
			- levý výstup = rotace údolí
			- pravý výstup = rotace hory
- bitonická třídička $B_n$
	- na vstupu bitonická posloupnost
	- na výstupu rostoucí posloupnost
	- čas $O(\log n)$
	- prostor $O(n\log n)$
- slévačka $M_n$
	- vstup: dvě monotónní rostoucí posloupnosti o $n$ prvcích
	- výstup: monotónní posloupnost o $2n$ prvcích
	- jednu z nich otočíme na klesající → dostaneme bitonickou posloupnost, proženeme ji $B_{2n}$
- třidička $S_n$
	- na vstupu je $n$ prvků
	- na výstupu je monotónní rostoucí posloupnost $n$ prvků
	- budeme mít $\log n$ pater slévaček, každá má nejhůř $\log n$ pater, takže celkem $O(\log^2n)$
	- prostorová složitost $O(n\log^2n)$
	- pozorování: prostorová složitost komparátorové sítě může být nejhůř $n$-krát větší než časová složitost
- pozorování: z dolního odhadu složitosti třídění plyne, že hloubka každé třídicí sítě je $\Omega(\log n)$
	- dá se to $O(\log n)$, ale konstanta je obrovská
- algoritmy odvozené od komparátorových sítí se velmi snadno vektorizují

## Dvojrozměrné úlohy


