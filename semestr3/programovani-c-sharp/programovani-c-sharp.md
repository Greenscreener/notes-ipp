# Programování v C\#

- zkouška bude podobná jako u Principů
- poznámky z cvičení
	- součástí zápočťáku je dokumentace, předvedení zápočťáku může být i online
	- zápočťák se teoreticky může dělat i ve skupině, ale není to praktické
	- body navíc za kvalitní řešení domácích úkolů
	- je třeba splnit úlohu tak, aby prošly všechny testy
	- kdybychom fakt nevěděli, kde je problém, můžeme napsat Kliberovi
	- používat .NET verze 7.0
- principy Pythonu
	- přiřazení do proměnné vytvoří objekt na garbage-collectované haldě s daty, jejich délkou a overheadem (obsahuje ref. count a datový typ)
	- odkaz (reference) na tento objekt se uloží do lokální paměti na místo vyhrazené dané proměnné
	- při provádění operací pomocí přetížených operátorů se kontrolují datové typy proměnných (uvnitř objektů na haldě) a podle toho se provede vhodná operace
- v C/C++
	- ukládá se rovnou hodnota, nevytváří se žádný objekt ani reference – proměnné se vytvářejí rovnou na místě (v lokální paměti)
	- objekty se taky ukládají do lokální paměti
	- pointery se chovají dost podobně – obsahují adresu proměnné
	- halda
		- na haldě se objekty alokují pomocí klíčového slova `new`
		- alokátor si udržuje overhead
		- dealokace se provádí explicitně pomocí `delete`
	- rozdíl mezi třídou a strukturou je ten, že obsah struktury je defaultně public
	- ochranu přístupu (public/private) kontroluje překladač, jinak se nikam neukládá
- C#
	- .NET
		- běhové prostředí (runtime), mj. alokátor proměti
		- standardní knihovny
	- v dotnetu může (kromě C#) běžet víc jazyků – Visual Basic .NET, F#, …
	- jsou věci, které platí pro C#, a věci, které platí pro .NET

## Typy

- základní dělení všech typů
	- pointery – jsou ošklivé, nebudeme se o nich bavit
	- hodnotové typy – alokované na místě (s výjimkami)
		- enums
		- structures
			- simple types (Int32, Int64, Double, Boolean, Char, …)
			- nullables
			- user defined structures (struct)
	- referenční typy – alokované na spravované (managed) haldě
		- classes (e.g. strings)
		- interfaces
		- arrays
		- delegates
- halda je garbage-collectovaná (GC), funguje chytřeji než v Pythonu, není potřeba reference counter, ale používá se graf dosažitelnosti
- overhead u každého objektu na haldě
	- syncblock – kvůli práci s více vlákny (u jednovláknových programů zbytečný)
	- pointer na typ (zjednodušeně řečeno)
		- třída System.Type, má instance na GC haldě
		- každý datový typ odpovídá jedné instanci třídy
	- na referenčních proměnných jde volat `.GetType()`
- `new` na hodnotovém typu (např. u typu struct) nealokuje nikde nic
- dotnetový typ `System.Int16` → C# klíčové slovo `short`
	- pokud klíčové slovo existuje, používáme ho
- v Javě se hodnotové typy označují malým písmenem, referenční velkým – v C# nic takového neplatí
- dotnet se vyvíjí rychleji než C#, takže např. System.Half ještě nemá klíčové slovo v C#
- odbočka: CLS compliant = všechny jazyky dotnetu musí tenhle typ podporovat (problém je hlavně s Javou, když se používá v dotnetu, všechny ostatní jazyky dotnetu nejspíš podporují všechny dotnetí typy)
- při přiřazování se v C# kopíruje obsah proměnné nezávisle na typu (takže u referenčních typů se kopíruje odkaz do GC haldy, u hodnotových typů samotná hodnota)
- třídy a struktury můžeme anotovat slovem `record`
	- např. `record class C {}`
	- při běhu se takové třídy/struktury chovají klasicky
	- umožní nám to psát méně boilerplate kódu, protože nám C# překladač vytvoří nějaké chytré metody (např. lepší ToString)
	- místo `record class` se dá napsat jenom `record`
- padding v lokální paměti
	- když překladač sází dvě 14B struktury vedle sebe do paměti, přičemž jejich první (vnitřní) proměnná má 8 B, tak mezi ně obvykle dá dva nulové bajty, ale struktury pořád vnímáme jako 14B
