# Programování v C\#

- zkouška bude podobná jako u Principů
- principy Pythonu
	- přiřazení do proměnné vytvoří objekt na garbage-collectované haldě s daty, jejich délkou a overheadem (obsahuje ref. count a datový typ)
	- odkaz (reference) na tento objekt se uloží do lokální paměti na místo vyhrazené dané proměnné
	- při provádění operací pomocí přetížených operátorů se kontrolují datové typy proměnných (uvnitř objektů na haldě) a podle toho se provede vhodná operace
- v C/C++
	- ukládá se rovnou hodnota, nevytváří se žádný objekt ani reference – proměnné se vytvářejí rovnou na místě (v lokální paměti)
	- objekty se taky ukládají do lokální paměti
	- pointery se chovají dost podobně – obsahují adresu proměnné
	- halda
		- na haldě se objekty alokují pomocí klíčového slova `new`
		- alokátor si udržuje overhead
		- dealokace se provádí explicitně pomocí `delete`
	- rozdíl mezi třídou a strukturou je ten, že obsah struktury je defaultně public
	- ochranu přístupu (public/private) kontroluje překladač, jinak se nikam neukládá
- C#
	- .NET
		- běhové prostředí (runtime), mj. alokátor proměti
		- standardní knihovny
	- v dotnetu může (kromě C#) běžet víc jazyků – Visual Basic .NET, F#, …
	- jsou věci, které platí pro C#, a věci, které platí pro .NET

## Typy

- základní dělení všech typů
	- pointery – jsou ošklivé, nebudeme se o nich bavit
	- hodnotové typy – alokované na místě (s výjimkami)
		- enums
		- structures
			- simple types (Int32, Int64, Double, Boolean, Char, …)
			- nullables
			- user defined structures (struct)
	- referenční typy – alokované na spravované (managed) haldě
		- classes (e.g. strings)
		- interfaces
		- arrays
		- delegates
- halda je garbage-collectovaná (GC), funguje chytřeji než v Pythonu, není potřeba reference counter, ale používá se graf dosažitelnosti
- overhead u každého objektu na haldě (má typicky 16 B)
	- syncblock – kvůli práci s více vlákny (u jednovláknových programů zbytečný), má 8 B
	- pointer na typ (zjednodušeně řečeno)
		- třída System.Type, má instance na GC haldě
		- každý datový typ odpovídá jedné instanci třídy
	- na referenčních proměnných jde volat `.GetType()`
- `new` na hodnotovém typu (např. u typu struct) nealokuje nikde nic
- dotnetový typ `System.Int16` → C# klíčové slovo `short`
	- pokud klíčové slovo existuje, používáme ho
- v Javě se hodnotové typy označují malým písmenem, referenční velkým – v C# nic takového neplatí
- dotnet se vyvíjí rychleji než C#, takže např. System.Half ještě nemá klíčové slovo v C#
- odbočka: CLS compliant = všechny jazyky dotnetu musí tenhle typ podporovat (problém je hlavně s Javou, když se používá v dotnetu, všechny ostatní jazyky dotnetu nejspíš podporují všechny dotnetí typy)
- při přiřazování se v C# kopíruje obsah proměnné nezávisle na typu (takže u referenčních typů se kopíruje odkaz do GC haldy, u hodnotových typů samotná hodnota)
- třídy a struktury můžeme anotovat slovem `record`
	- např. `record class C {}`
	- při běhu se takové třídy/struktury chovají klasicky
	- umožní nám to psát méně boilerplate kódu, protože nám C# překladač vytvoří nějaké chytré metody (např. lepší ToString)
	- místo `record class` se dá napsat jenom `record`

---

- jak rozlišit, kdy použít referenční a kdy hodnotový typ
- syntaktický cukr – `var` a `new()`
- fields a ochrana přístupu (public, readonly, …)
- properties – gettery, settery
	- auto-implemented props
		- automaticky se vytvoří backing field
		- props bez setteru jsou readonly
		- getter a setter můžou mít různou viditelnost (celku se nastaví nějaká viditelnost, u getteru nebo setteru se pak napíše jiná viditelnost)
- do readonly věcí můžu zapisovat v konstruktoru
- výchozí hodnoty typů
- za `new X()` můžu do složených závorek napsat do složených závorek nastavení hodnot fieldů (ale je to syntaktický cukr pro nastavení hodnot fieldů po skončení běhu konstruktoru, úroveň přístupu odpovídá úrovni okolního kódu – takže to funguje podobně, jako bychom přiřazení provedli až dodatečně na dalším řádku; jediný rozdíl spočívá v klíčovém slově `init`)
- ve složených závorkách za `new X()` je inicializér
- klíčové slovo `init` se používá podobně jako `set` (nedají se použít zároveň), akorát `init` umožňuje přiřazení pouze v konstruktoru nebo v inicializéru
- klíčové slovo required – danému fieldu/property musím nastavit hodnotu do konce běhu inicializéru
- u bezparametrických konstruktorů nemusím psát závorky, takže stačí `new X`
- primary constructors – v C# 12, fieldy píšu do závorky za `class C`
	- můžu definovat property vycházející z nějakého fieldu
	- C# 10 umožňuje u record class automaticky vygenerovat vlastnosti tímto způsobem – u record class (v C# 11) jsou vlastnosti immutable (mají get, init), u record struct jsou vlastnosti mutable (mají get a set)
	- pro readonly record struct se generují immutable vlastnosti (?)
- klíčové slovo record se hodí na vytváření jednoduchých „datonosných“ tříd
- nullable hodnotové typy – pomocí otazníku, vytvoří se generická struktura Nullable, je tam boolean vlastnost HasValue
	- lze přetěžovat porovnání, takže někdy může být problém porovnávat s nullem → může se hodit použít operátor `is` nebo `is not`

---

- `null` původně vychází z referenčních typů
	- `null` = neplatná reference
	- `null` se dá běžně používat u referenčních typů
	- proměnná jakoby odkazuje na adresu 0 (což je ale v operačním systému neplatné mapování)
- runtimu dotnetu se říká CLR (Common Language Runtime)
- CLR u dereferencí proměnných (vlastností apod.) uvnitř proměnných referenčních typů kontroluje, jestli referenční proměnné nejsou null (tedy např. `x = null; Console.WriteLine(x.y);` vyhodí NullReferenceException)
- pokud se pokusíme vypsat null, tak Console.WriteLine automaticky vypíše prázdný řetězec a nevolá ToString (kdybychom ToString zavolali ručně, tak to při kontrole – viz výše)
- trik s rychlým překomentováním pomocí `/**/` a `/*/`
- nová sémantika referenčních typů od C# 8
	- v ReCodExu je vypnutá, ve Visual Studiu je obvykle zapnutá
	- když do zdrojáku napíšu `#nullable enable`, tak se zapne nová sémantika
	- jakmile se zapne, referenční typy nejsou nullable, je potřeba to zapínat otazníkem u každé proměnné
	- pak se můžu spolehnout na invariant, že daná proměnná nikdy nebude null
	- pokud do non-nullable referenční proměnné přiřadím null, tak to vypíše warning
		- statická analýza neumí říct stoprocentně správně, jestli je přiřazení nullu v danou chvíli špatně, takže nevrací error, ale jenom warning
- koncepční rozdíl mezi C# a Pythonem
	- Python – duck typing
		- ke kachní poště nepotřebujme kachnu, ale něco, co je kachně dostatečně podobné v těch důležitých vlastnostech
		- implicitně kódem sděluju, co potřebuju od dané proměnné
		- můžu danému kódu přiřadit cokoliv, co dané vlastnosti splňuje (kontroluje se to až za runtimu)
		- duck typing funguje i v C++ u generických typů (ale nejčastěji se objevuje v dynamicky typovaných jazycích)
	- C#
		- definuju si kontrakt
			- někdo ho implemenuje (slibuje, že má minimálně metody předepsané kontraktem)
			- někdo ho využívá (slib, že používá maximálně metody z kontraktu)
			- lze to vynucovat více způsoby, ale nejtypičtější jsou interfacy
		- interface – referenční typ
			- konvence psát na začátek názvu `I`
			- dovnitř se píšou metody / method-like věci (třeba props), nesmí tam být fields
			- jeden řádek může být např. `public int m(int a, int b);`
			- dříve muselo být všechno public, dneska je dobré tam to public explicitně psát (i když defaultně je pořád všechno public)
			- názvy parametrů metod v interfacu slouží k dokumentaci
			- nemůže existovat instance interfacu, pouze proměnná s typem interfacu (ta může být nullable)
			- `class Kachna : IPostovniZvire {…}`
			- `IPostovniZvire zvire1 = new Kachna();`
			- třída může implementovat víc interfaců
		- přístup CLR k implementaci metod
			- synovská třída dědí implementaci metody u rodiče
			- každý interface u třídy vytvoří jakoby tabulku metod, ta se zaplní reálnými implementacemi (respektive ukazateli na implementace)
			- obecně může nastat, že rodič interface neimplementuje, ale syn ano
			- tabulky jsou uloženy v instanci třídy Type (v overheadu daného objektu na haldě)
			- typ proměnné rozhoduje, jakou metodu volám
				- je to důležité při překrývání metod pomocí `new`
				- pokud je to interfacová metoda, tak záleží na tom, kam ukazuje tabulka, což vyplývá z toho, která třída implementuje interface
			- pokud chci s nějakým objektem (typicky z interfacu nebo taky u syna rodičovské třídy) zacházet speciálně podle konkrétní třídy, jejíž je instancí, můžu použít operátor `is` a pak ho castnout
				- klasický zápis: `if (a is B) {B b = (b)a; …}`
				- zkrácený zápis: `if (a is B b) {…}`
				- pokud C dědí od B, přičemž B dědí od A, pak instanci třídy C lze takto castnout do B i C (a samozřejmě i do A) – tzn. pro všechny tyto typy vrací operátor `is` hodnotu `true`

---

- C++
	- zdrojáky .cpp, jeden po druhém je překládáme, vznikají object fily .obj (nebo .o), tam je přímo strojový kód
		- ty se linkerem zpracují do jednoho .exe souboru
	- strojový kód typicky cílí na konkrétní platformu
	- kdybych chtěl, aby program běžel na jiné platformě, vezmu zdrojový kód a celý ho znova přeložím
	- 64bitové Windows podporují 32bitové programy
	- uživatelé musí vědět, jakou verzi programu si mají vybrat
	- knihovny
		- překladač programu používá hlavičkové soubory knihoven
- Apple
	- Apple 6502 → Motorola 68000 (32bit) → IBM PowerPC (32bit) → Intel x86 (32bit) → Intel x64 (64bit) → Apple M1/M2 (ARM64, 64bit)
	- vymysleli fat binary (universal executable) – jeden spustitelný soubor, v něm je více verzí programu najednou
	- řeší to problém zpětné kompatibility, ne dopředné
- C\#
	- soubory .cs
	- .csproj, předává se build systému dotnetu, ten pustí C# compiler csc.exe (dnes css.dll)
	- vypadne z toho executable, uvnitř je CIL kód (common intermediate language)
	- ke spuštění programu potřebujeme CLR (common language runtime), obvykle je tam JIT (just-in-time) překladač, ten zajišťuje překlad a spuštění pro konkrétní platformu
	- CLR … virtual machine (VM)
	- CIL kód … managed/řízený kód
	- dotnet executable soubor … assembly
	- Java to má podobně
		- Java intermediate language = Java bytecode
	- všechny programovací jazyky dotnetu se překládají do CIL kódu
	- optimalizace dělá až JIT
		- ale má na to omezený čas, aby se program spustil dostatečně rychle
	- JIT používá překlad po metodách
	- ale dá se použít AOT (ahead of time) překlad – takže pak v .exe souboru je nejen assembly (ten se použije pro nepodporované platformy), ale taky přímo strojový kód, který tak může být efektivnější
		- některé věci tam nefungují
	- knihovna se překládá velmi podobně
		- .csproj + .cs soubory
		- csc přeloží na .dll soubor
		- rozdíl mezi .exe a .dll není skoro žádný, akorát .exe má entry point (dneska může být i executable .dll s entry pointem, takže podle přípony to není poznat)
	- v .exe/.dll souboru je vždy CIL kód a metadata
	- když v programu používám knihovnu, odkazuju se při překladu přímo na její .dll soubor (metadata uvnitř)
	- v metadatech musí být v zásadě celá hlavička metody (včetně názvů parametrů – kvůli dokumentaci a explicitnímu přiřazení)
	- od dotnetu 5
		- a.exe soubor … Windows loader
			- spustí správný soubor clr.dll
			- jeho pomocí spoustí a.dll soubor
		- nástroj dotnet
			- obsahuje SDK toolchain
			- provádí nalezení správného souboru clr.dll a spuštění a.dll souboru (to je užitečné hlavně mimo Windows)
			- stačí napsat `dotnet a.dll`
			- `dotnet a.exe` nefunguje, protože exe soubor se nedá spustit jako dotnetí
	- pomocí nástroje ildasm.exe se můžeme podívat dovnitř metadat a CIL kódu
	- ILSpy je dekompiler, který zkouší obnovit původní kód
	- kromě dll a exe souboru se k programu obvykle generuje i .pdb soubor s informacemi k debugování (typicky názvy lokálních proměnných)
		- ten pak používá i ILSpy, pokud je k dispozici
- dědičnost/inheritance
	- class A
	- class B : A
	- dědění (kopírování dat) probíhá až v JIT
	- v B je všechno, co bylo v A, kromě konstruktoru
		- instanční
			- fields
			- methods
		- statické
			- fields
			- methods
	- instanční metoda má implicitní parametr this, který je typu dané třídy
	- u rodiče se někdy hodí klíčové slovo abstract, to zakazuje vytváření instancí dané třídy
	- třída může implementovat libovolné množství interfaců
	- každá třída má právě jednoho předka (pokud jsme žádného nedefinovali, tak je to Object)
	- typy v C# (kromě pointerů) tvoří strom
	- konstruktory se nedědí
		- konstruktor můžu chápat jako instanční metodu
		- volání rodičovského konstruktoru zajišťuje klíčové slovo base
			- `public B(params1):base(params2) {`
			- není to optional, rodičovský konstruktor se volá pokaždé (defaultně bez parametrů)
		- konstruktor předka se vždy volá před konstruktorem potomka
	- `a is B` vs. `a.GetType() == typeof(B)`
		- první varianta se ptá, jestli to, co je v `a`, je přiřaditelné do typu `B`
		- druhá varianta se ptá, jestli typy přesně odpovídají
		- druhá varianta je mírně rychlejší
