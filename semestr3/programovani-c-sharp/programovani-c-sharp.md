# Programování v C\#

- zkouška bude podobná jako u Principů
- principy Pythonu
	- přiřazení do proměnné vytvoří objekt na garbage-collectované haldě s daty, jejich délkou a overheadem (obsahuje ref. count a datový typ)
	- odkaz (reference) na tento objekt se uloží do lokální paměti na místo vyhrazené dané proměnné
	- při provádění operací pomocí přetížených operátorů se kontrolují datové typy proměnných (uvnitř objektů na haldě) a podle toho se provede vhodná operace
- v C/C++
	- ukládá se rovnou hodnota, nevytváří se žádný objekt ani reference – proměnné se vytvářejí rovnou na místě (v lokální paměti)
	- objekty se taky ukládají do lokální paměti
	- pointery se chovají dost podobně – obsahují adresu proměnné
	- halda
		- na haldě se objekty alokují pomocí klíčového slova `new`
		- alokátor si udržuje overhead
		- dealokace se provádí explicitně pomocí `delete`
	- rozdíl mezi třídou a strukturou je ten, že obsah struktury je defaultně public
	- ochranu přístupu (public/private) kontroluje překladač, jinak se nikam neukládá
- C#
	- .NET
		- běhové prostředí (runtime), mj. alokátor proměti
		- standardní knihovny
	- v dotnetu může (kromě C#) běžet víc jazyků – např. Visual Basic .NET, F#, …
	- jsou věci, které platí pro C#, a věci, které platí pro .NET

## Typy

- základní dělení všech typů
	- pointery – jsou ošklivé, nebudeme se o nich bavit
	- hodnotové typy – alokované na místě (s výjimkami)
		- enums
		- structures
			- simple types (Int32, Int64, Double, Boolean, Char, …)
			- nullables
			- user defined structures (struct)
	- referenční typy – alokované na spravované (managed) haldě
		- classes (e.g. strings)
		- interfaces
		- arrays
		- delegates
- halda je garbage-collectovaná (GC), funguje chytřeji než v Pythonu, není potřeba reference counter, ale používá se graf dosažitelnosti
- overhead u každého objektu na haldě (má typicky 16 B)
	- syncblock – kvůli práci s více vlákny (u jednovláknových programů zbytečný), má 8 B
	- pointer na typ (zjednodušeně řečeno)
		- třída System.Type, má instance na GC haldě
		- každý datový typ odpovídá jedné instanci třídy
	- na referenčních proměnných jde volat `.GetType()`
- `new` na hodnotovém typu (např. u typu struct) nealokuje nikde nic
- dotnetový typ `System.Int16` → C# klíčové slovo `short`
	- pokud klíčové slovo existuje, používáme ho
- v Javě se hodnotové typy označují malým písmenem, referenční velkým – v C# nic takového neplatí
- dotnet se vyvíjí rychleji než C#, takže např. System.Half ještě nemá klíčové slovo v C#
- odbočka: CLS compliant = všechny jazyky dotnetu musí tenhle typ podporovat (problém je hlavně s Javou, když se používá v dotnetu, všechny ostatní jazyky dotnetu nejspíš podporují všechny dotnetí typy)
- při přiřazování se v C# kopíruje obsah proměnné nezávisle na typu (takže u referenčních typů se kopíruje odkaz do GC haldy, u hodnotových typů samotná hodnota)
- třídy a struktury můžeme anotovat slovem `record`
	- např. `record class C {}`
	- při běhu se takové třídy/struktury chovají klasicky
	- umožní nám to psát méně boilerplate kódu, protože nám C# překladač vytvoří nějaké chytré metody (např. lepší ToString)
	- místo `record class` se dá napsat jenom `record`
- jak rozlišit, kdy použít referenční a kdy hodnotový typ
- syntaktický cukr – `var` a `new()`
- fields a ochrana přístupu (public, readonly, …)
- properties – gettery, settery
	- auto-implemented props
		- automaticky se vytvoří backing field
		- props bez setteru jsou readonly
		- getter a setter můžou mít různou viditelnost (celku se nastaví nějaká viditelnost, u getteru nebo setteru se pak napíše jiná viditelnost)
- do readonly věcí můžu zapisovat v konstruktoru
- výchozí hodnoty typů
- za `new X()` můžu do složených závorek napsat do složených závorek nastavení hodnot fieldů (ale je to syntaktický cukr pro nastavení hodnot fieldů po skončení běhu konstruktoru, úroveň přístupu odpovídá úrovni okolního kódu – takže to funguje podobně, jako bychom přiřazení provedli až dodatečně na dalším řádku; jediný rozdíl spočívá v klíčovém slově `init`)
- ve složených závorkách za `new X()` je inicializér
- klíčové slovo `init` se používá podobně jako `set` (nedají se použít zároveň), akorát `init` umožňuje přiřazení pouze v konstruktoru nebo v inicializéru
- klíčové slovo required – danému fieldu/property musím nastavit hodnotu do konce běhu inicializéru
- u bezparametrických konstruktorů nemusím psát závorky, takže stačí `new X`
- primary constructors – v C# 12, fieldy píšu do závorky za `class C`
	- můžu definovat property vycházející z nějakého fieldu
	- C# 10 umožňuje u record class automaticky vygenerovat vlastnosti tímto způsobem – u record class (v C# 11) jsou vlastnosti immutable (mají get, init), u record struct jsou vlastnosti mutable (mají get a set)
	- pro readonly record struct se generují immutable vlastnosti (?)
- klíčové slovo record se hodí na vytváření jednoduchých „datonosných“ tříd
- nullable hodnotové typy – pomocí otazníku, vytvoří se generická struktura Nullable, je tam boolean vlastnost HasValue
	- lze přetěžovat porovnání, takže někdy může být problém porovnávat s nullem → může se hodit použít operátor `is` nebo `is not`
- `null` původně vychází z referenčních typů
	- `null` = neplatná reference
	- `null` se dá běžně používat u referenčních typů
	- proměnná jakoby odkazuje na adresu 0 (což je ale v operačním systému neplatné mapování)
- runtimu dotnetu se říká CLR (Common Language Runtime)
- CLR u dereferencí proměnných (vlastností apod.) uvnitř proměnných referenčních typů kontroluje, jestli referenční proměnné nejsou null (tedy např. `x = null; Console.WriteLine(x.y);` vyhodí NullReferenceException)
- pokud se pokusíme vypsat null, tak Console.WriteLine automaticky vypíše prázdný řetězec a nevolá ToString (kdybychom ToString zavolali ručně, tak to při kontrole – viz výše)
- trik s rychlým překomentováním pomocí `/**/` a `/*/`
- nová sémantika referenčních typů od C# 8
	- v ReCodExu je vypnutá, ve Visual Studiu je obvykle zapnutá
	- když do zdrojáku napíšu `#nullable enable`, tak se zapne nová sémantika
	- jakmile se zapne, referenční typy nejsou nullable, je potřeba to zapínat otazníkem u každé proměnné
	- pak se můžu spolehnout na invariant, že daná proměnná nikdy nebude null
	- pokud do non-nullable referenční proměnné přiřadím null, tak to vypíše warning
		- statická analýza neumí říct stoprocentně správně, jestli je přiřazení nullu v danou chvíli špatně, takže nevrací error, ale jenom warning

## Kontrakt a rozhraní (interfaces)

- koncepční rozdíl mezi C# a Pythonem
	- Python – duck typing
		- ke kachní poště nepotřebujme kachnu, ale něco, co je kachně dostatečně podobné v těch důležitých vlastnostech
		- implicitně kódem sděluju, co potřebuju od dané proměnné
		- můžu danému kódu přiřadit cokoliv, co dané vlastnosti splňuje (kontroluje se to až za runtimu)
		- duck typing funguje i v C++ u generických typů (ale nejčastěji se objevuje v dynamicky typovaných jazycích)
	- C#
		- definuju si kontrakt
			- někdo ho implemenuje (slibuje, že má minimálně metody předepsané kontraktem)
			- někdo ho využívá (slib, že používá maximálně metody z kontraktu)
			- lze to vynucovat více způsoby, ale nejtypičtější jsou interfacy
		- interface – referenční typ
			- konvence psát na začátek názvu `I`
			- dovnitř se píšou metody / method-like věci (třeba props), nesmí tam být fields
			- jeden řádek může být např. `public int m(int a, int b);`
			- dříve muselo být všechno public, dneska je dobré tam to public explicitně psát (i když defaultně je pořád všechno public)
			- názvy parametrů metod v interfacu slouží k dokumentaci
			- nemůže existovat instance interfacu, pouze proměnná s typem interfacu (ta může být nullable)
			- `class Kachna : IPostovniZvire {…}`
			- `IPostovniZvire zvire1 = new Kachna();`
			- třída může implementovat víc interfaců
		- přístup CLR k implementaci metod
			- synovská třída dědí implementaci metody u rodiče
			- každý interface u třídy vytvoří jakoby tabulku metod, ta se zaplní reálnými implementacemi (respektive ukazateli na implementace)
			- obecně může nastat, že rodič interface neimplementuje, ale syn ano
			- tabulky jsou uloženy v instanci třídy Type (v overheadu daného objektu na haldě)
			- typ proměnné rozhoduje, jakou metodu volám
				- je to důležité při překrývání metod pomocí `new`
				- pokud je to interfacová metoda, tak záleží na tom, kam ukazuje tabulka, což vyplývá z toho, která třída implementuje interface
			- pokud chci s nějakým objektem (typicky z interfacu nebo taky u syna rodičovské třídy) zacházet speciálně podle konkrétní třídy, jejíž je instancí, můžu použít operátor `is` a pak ho castnout
				- klasický zápis: `if (a is B) {B b = (b)a; …}`
				- zkrácený zápis: `if (a is B b) {…}`
				- pokud C dědí od B, přičemž B dědí od A, pak instanci třídy C lze takto castnout do B i C (a samozřejmě i do A) – tzn. pro všechny tyto typy vrací operátor `is` hodnotu `true`

## Překlad a distribuce programů

- C++
	- zdrojáky .cpp, jeden po druhém je překládáme, vznikají object fily .obj (nebo .o), tam je přímo strojový kód
		- ty se linkerem zpracují do jednoho .exe souboru
	- strojový kód typicky cílí na konkrétní platformu
	- kdybych chtěl, aby program běžel na jiné platformě, vezmu zdrojový kód a celý ho znova přeložím
	- 64bitové Windows podporují 32bitové programy
	- uživatelé musí vědět, jakou verzi programu si mají vybrat
	- knihovny
		- překladač programu používá hlavičkové soubory knihoven
- Apple
	- Apple 6502 → Motorola 68000 (32bit) → IBM PowerPC (32bit) → Intel x86 (32bit) → Intel x64 (64bit) → Apple M1/M2 (ARM64, 64bit)
	- vymysleli fat binary (universal executable) – jeden spustitelný soubor, v něm je více verzí programu najednou
	- řeší to problém zpětné kompatibility, ne dopředné
- C\#
	- soubory .cs
	- .csproj, předává se build systému dotnetu, ten pustí C# compiler csc.exe (dnes css.dll)
	- vypadne z toho executable, uvnitř je CIL kód (common intermediate language)
	- ke spuštění programu potřebujeme CLR (common language runtime), obvykle je tam JIT (just-in-time) překladač, ten zajišťuje překlad a spuštění pro konkrétní platformu
	- CLR … virtual machine (VM)
	- CIL kód … managed/řízený kód
	- dotnet executable soubor … assembly
	- Java to má podobně
		- Java intermediate language = Java bytecode
	- všechny programovací jazyky dotnetu se překládají do CIL kódu
	- optimalizace dělá až JIT
		- ale má na to omezený čas, aby se program spustil dostatečně rychle
	- JIT používá překlad po metodách
	- ale dá se použít AOT (ahead of time) překlad – takže pak v .exe souboru je nejen assembly (ten se použije pro nepodporované platformy), ale taky přímo strojový kód, který tak může být efektivnější
		- některé věci tam nefungují
	- knihovna se překládá velmi podobně
		- .csproj + .cs soubory
		- csc přeloží na .dll soubor
		- rozdíl mezi .exe a .dll není skoro žádný, akorát .exe má entry point (dneska může být i executable .dll s entry pointem, takže podle přípony to není poznat)
	- v .exe/.dll souboru je vždy CIL kód a metadata
	- když v programu používám knihovnu, odkazuju se při překladu přímo na její .dll soubor (metadata uvnitř)
	- v metadatech musí být v zásadě celá hlavička metody (včetně názvů parametrů – kvůli dokumentaci a explicitnímu přiřazení)
	- od dotnetu 5
		- a.exe soubor … Windows loader
			- spustí správný soubor clr.dll
			- jeho pomocí spoustí a.dll soubor
		- nástroj dotnet
			- obsahuje SDK toolchain
			- provádí nalezení správného souboru clr.dll a spuštění a.dll souboru (to je užitečné hlavně mimo Windows)
			- stačí napsat `dotnet a.dll`
			- `dotnet a.exe` nefunguje, protože exe soubor se nedá spustit jako dotnetí
	- pomocí nástroje ildasm.exe se můžeme podívat dovnitř metadat a CIL kódu
	- ILSpy je dekompiler, který zkouší obnovit původní kód
	- kromě dll a exe souboru se k programu obvykle generuje i .pdb soubor s informacemi k debugování (typicky názvy lokálních proměnných)
		- ten pak používá i ILSpy, pokud je k dispozici

## Dědičnost

- dědičnost/inheritance
	- class A
	- class B : A
	- dědění (kopírování dat) probíhá až v JIT
	- v B je všechno, co bylo v A, kromě konstruktoru
		- instanční
			- fields
			- methods
		- statické
			- fields
			- methods
	- instanční metoda má implicitní parametr this, který je typu dané třídy
	- u rodiče se někdy hodí klíčové slovo abstract, to zakazuje vytváření instancí dané třídy
	- třída může implementovat libovolné množství interfaců
	- každá třída má právě jednoho předka (pokud jsme žádného nedefinovali, tak je to Object)
	- typy v C# (kromě pointerů) tvoří strom
	- konstruktory se nedědí
		- konstruktor můžu chápat jako instanční metodu
		- volání rodičovského konstruktoru zajišťuje klíčové slovo base
			- `public B(params1):base(params2) {`
			- není to optional, rodičovský konstruktor se volá pokaždé (defaultně bez parametrů)
		- konstruktor předka se vždy volá před konstruktorem potomka
	- `a is B` vs. `a.GetType() == typeof(B)`
		- první varianta se ptá, jestli to, co je v `a`, je přiřaditelné do typu `B`
		- druhá varianta se ptá, jestli typy přesně odpovídají
		- druhá varianta je mírně rychlejší
	- `is` za runtimu vyhodnocuje, zda instance splňuje nějakou podmínku
		- `a is PODMINKA-NA-INSTANCI`
		- `a is null`
		- skládání podmínek se provádí pomocí „slovních“ operátorů `and`, `or`, `not`
		- pro nullable typ `Person?` můžu provést kontrolu pomocí `is not null` nebo `is Person person`
		- operátor `.` vs. null-forgiving operátor `?.`
			- `a.Length` vs. `a?.Length`
			- obdobně `a[index]` vs. `a?[index]`
			- typ výsledku se liší v nullabilitě (pokud by `a.Length` bylo typu `X`, `a?.Length` bude typu `X?`)
		- příklad použití ke zpřehlednění kódu
			- zadání: nemá platit, že x je menší než 4
			- implementace 1: `x >= 4`
			- implementace 2: `!(x < 4)`
			- implementace 3: `x is not < 4`
			- skládání: `x is not null and not < 4`
				- pokud by `x` byla vlastnost (property), tak se getter zavolá pouze jednou (pro klasické boolovské výrazy by se volal dvakrát: `x != null && x >= 4`)
		- dá se použít syntaktická zkratka `person is { FirstName: "Vít", LastName: "Kološ" }`
		- občas se místo not null používá `is {}`, ale není to moc praktické
		- dá se to složit na `person is Employee { Salary: > 500, LastName: "Kološ" } employee`
		- zároveň můžu rovnou přiřadit do proměnné `person is Employee { Salary: > 500, Salary: var salary, LastName: "Kološ" } employee`

---

- občas je praktické uložit nějakou hodnotu jako konstantu
- konstanty uvnitř tříd
	- `readonly int x1;` – ukládá se u každé instance, což se nám nehodí
	- `static readonly int x2;`
		- je uložený pouze jednou, ale pracuje se s ním jako s proměnnou (ve strojovém kódu se vykonává load z paměti…)
	- `const int x3 = 5;`
		- je to konstanta pro celou třídu, nezabírá to místo, hodnota je uložena přímo v metadatech, překladač optimalizuje počítání s konstantami (takže předem provede některé výpočty)
		- do takové konstanty lze uložit jen základní hodnotové typy a pro stringy – pokud nám to nestačí, tak musíme použít static readonly
		- pokud konstanty používáme v knihovnách, tak se může stát, že vydáme novou verzi knihovny, někdo si ji stáhne, ale přitom bude mít starou verzi programu, v níž bude „zakompilovaná“ stará konstanta ze staré verze knihovny
- class constructor
	- metoda bez parametrů, volá ji automaticky CLR
	- zavolá se před prvním použitím toho typu jako takového
	- není úplně jasné, kdy přesně se zavolá
	- pokud se daný typ používá a je možné, že jeho class constructor ještě nebyl zavolán, provede se kontrola tohoto zavolání a následně se přípradně zavolá
		- může nastat situace, že by se tato kontrola prováděla při každém volání funkce, kterou je ale potřeba volat mnohokrát – v takovém případě může být vhodné této kontrole zabránit např. vytvořením zbytečné (prázdné) instance objektu daného typu někdy na začátku programu
	- class konstruktor se generuje automaticky, ale dá se napsat ručně – název metody odpovídá názvu třídy, použije se klíčové slovo static, viditelnost se neuvádí
- každá třída má právě jeden konstruktor, který inicializuje danou instanci – ostatní musí volat nějaký jiný konstruktor pomocí this()
	- dovnitř se automaticky generují inicializace fieldů u objektu
	- kód ve složených závorkách za this() se provede až po volání tohoto konstruktoru
	- nejdřív se inicializují fieldy a volají se funkce potřebné k jejich inicializaci → pak se volá this() nebo base() → pak se provádí kód ve složených závorkách
	- tohle je vlastnost C#, ne CLR
	- když zkusíme během inicializace fieldů přistoupit k neinicializovanému fieldu, tak tam bude nula (tzn. 0, null nebo false)
- konstruktor se v CLR označuje jako `.ctor`, class konstruktor jako `.cctor`
- namespaces jsou syntaktická zkratka C#, CLR zná třídy pouze pod jejich celými jmény (tzn. namespace.třída), přičemž pro něj tečka nemá žádný speciální význam (pro C# samozřejmě ano)
- dalším výrazem, jehož hodnota se generuje za překladu, je nameof(proměnná)
	- typické použití k uvedení jména argumentu při vyhození ArgumentException
	- nameof(x) je ekvivalentní se zápisem "x", ale když proměnnou x přejmenuju, tak na "x" snadno zapomenu
- když píšu číslo a chci ho zpřehlednit, tak můžu použít podtržítko
	- např. `int speed = 300_000;`
- výčtové typy (enum)
	- hodnotový typ
	- předává se jako int (nebo jiný základní typ)
	- s proměnnými můžu provádět aritmetické operace, ale musím hlídat, jestli se nedostanu mimo definované hodnoty (pak se s proměnnou zachází jako s klasickým číslem)
	- metoda ToString defaultně vrací název dané hodnoty v enumu (pro nedefinovanou hodnotu vrátí číslo)
	- lze ručně nastavit hodnoty, pokud danou hodnotu nenastavím, tak se vezme předchozí hodnota a zvýší se o jedna
		- hodnoty můžou být i stejné – pak se tyto hodnoty při porovnání rovnají, ToString vypíše tu, která je v seznamu uvedena jako první
		- někdy se enum používá jako bitová maska – takže jako hodnoty přiřadíme mocniny dvojky, s označením `[Flags]` tento přístup podporuje i ToString (vypíše seznam „zvolených hodnot“)
	- existuje *hodně pomalá* metoda Enum.Parse, která pro zadaný název hodnoty v enumu dokáže najít číslo (funguje i pro Flags)
		- používá koncept reflection
- klíčové slovo using umožňuje nastavit alias pro název typu (např. `using X = Console;`), funguje i global using
	- má to smysl jen ve výjimečných situacích (pokud má něco krkolomný název)
- situace: chceme mít uložený řádek a sloupec tabulky a chceme předejít tomu, abychom ta dvě čísla zaměnili
	- je vhodné řešení pomocí struktur (takže budu mít např. `Row.Value`)
	- není až tak rozumné použít enum
