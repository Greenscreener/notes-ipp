# Programování v C\#

- zkouška bude podobná jako u Principů
- principy Pythonu
	- přiřazení do proměnné vytvoří objekt na garbage-collectované haldě s daty, jejich délkou a overheadem (obsahuje ref. count a datový typ)
	- odkaz (reference) na tento objekt se uloží do lokální paměti na místo vyhrazené dané proměnné
	- při provádění operací pomocí přetížených operátorů se kontrolují datové typy proměnných (uvnitř objektů na haldě) a podle toho se provede vhodná operace
- v C/C++
	- ukládá se rovnou hodnota, nevytváří se žádný objekt ani reference – proměnné se vytvářejí rovnou na místě (v lokální paměti)
	- objekty se taky ukládají do lokální paměti
	- pointery se chovají dost podobně – obsahují adresu proměnné
	- halda
		- na haldě se objekty alokují pomocí klíčového slova `new`
		- alokátor si udržuje overhead
		- dealokace se provádí explicitně pomocí `delete`
	- rozdíl mezi třídou a strukturou je ten, že obsah struktury je defaultně public
	- ochranu přístupu (public/private) kontroluje překladač, jinak se nikam neukládá
- C#
	- .NET
		- běhové prostředí (runtime), mj. alokátor proměti
		- standardní knihovny
	- v dotnetu může (kromě C#) běžet víc jazyků – Visual Basic .NET, F#, …
	- jsou věci, které platí pro C#, a věci, které platí pro .NET

## Typy

- základní dělení všech typů
	- pointery – jsou ošklivé, nebudeme se o nich bavit
	- hodnotové typy – alokované na místě (s výjimkami)
		- enums
		- structures
			- simple types (Int32, Int64, Double, Boolean, Char, …)
			- nullables
			- user defined structures (struct)
	- referenční typy – alokované na spravované (managed) haldě
		- classes (e.g. strings)
		- interfaces
		- arrays
		- delegates
- halda je garbage-collectovaná (GC), funguje chytřeji než v Pythonu, není potřeba reference counter, ale používá se graf dosažitelnosti
- overhead u každého objektu na haldě (má typicky 16 B)
	- syncblock – kvůli práci s více vlákny (u jednovláknových programů zbytečný), má 8 B
	- pointer na typ (zjednodušeně řečeno)
		- třída System.Type, má instance na GC haldě
		- každý datový typ odpovídá jedné instanci třídy
	- na referenčních proměnných jde volat `.GetType()`
- `new` na hodnotovém typu (např. u typu struct) nealokuje nikde nic
- dotnetový typ `System.Int16` → C# klíčové slovo `short`
	- pokud klíčové slovo existuje, používáme ho
- v Javě se hodnotové typy označují malým písmenem, referenční velkým – v C# nic takového neplatí
- dotnet se vyvíjí rychleji než C#, takže např. System.Half ještě nemá klíčové slovo v C#
- odbočka: CLS compliant = všechny jazyky dotnetu musí tenhle typ podporovat (problém je hlavně s Javou, když se používá v dotnetu, všechny ostatní jazyky dotnetu nejspíš podporují všechny dotnetí typy)
- při přiřazování se v C# kopíruje obsah proměnné nezávisle na typu (takže u referenčních typů se kopíruje odkaz do GC haldy, u hodnotových typů samotná hodnota)
- třídy a struktury můžeme anotovat slovem `record`
	- např. `record class C {}`
	- při běhu se takové třídy/struktury chovají klasicky
	- umožní nám to psát méně boilerplate kódu, protože nám C# překladač vytvoří nějaké chytré metody (např. lepší ToString)
	- místo `record class` se dá napsat jenom `record`

---

- jak rozlišit, kdy použít referenční a kdy hodnotový typ
- syntaktický cukr – `var` a `new()`
- fields a ochrana přístupu (public, readonly, …)
- properties – gettery, settery
	- auto-implemented props
		- automaticky se vytvoří backing field
		- props bez setteru jsou readonly
		- getter a setter můžou mít různou viditelnost (celku se nastaví nějaká viditelnost, u getteru nebo setteru se pak napíše jiná viditelnost)
- do readonly věcí můžu zapisovat v konstruktoru
- výchozí hodnoty typů
- za `new X()` můžu do složených závorek napsat do složených závorek nastavení hodnot fieldů (ale je to syntaktický cukr pro nastavení hodnot fieldů po skončení běhu konstruktoru, úroveň přístupu odpovídá úrovni okolního kódu – takže to funguje podobně, jako bychom přiřazení provedli až dodatečně na dalším řádku; jediný rozdíl spočívá v klíčovém slově `init`)
- ve složených závorkách za `new X()` je inicializér
- klíčové slovo `init` se používá podobně jako `set` (nedají se použít zároveň), akorát `init` umožňuje přiřazení pouze v konstruktoru nebo v inicializéru
- klíčové slovo required – danému fieldu/property musím nastavit hodnotu do konce běhu inicializéru
- u bezparametrických konstruktorů nemusím psát závorky, takže stačí `new X`
- primary constructors – v C# 12, fieldy píšu do závorky za `class C`
	- můžu definovat property vycházející z nějakého fieldu
	- C# 10 umožňuje u record class automaticky vygenerovat vlastnosti tímto způsobem – u record class (v C# 11) jsou vlastnosti immutable (mají get, init), u record struct jsou vlastnosti mutable (mají get a set)
	- pro readonly record struct se generují immutable vlastnosti (?)
- klíčové slovo record se hodí na vytváření jednoduchých „datonosných“ tříd
- nullable hodnotové typy – pomocí otazníku, vytvoří se generická struktura Nullable, je tam boolean vlastnost HasValue
	- lze přetěžovat porovnání, takže někdy může být problém porovnávat s nullem → může se hodit použít operátor `is` nebo `is not`

---

- `null` původně vychází z referenčních typů
	- `null` = neplatná reference
	- `null` se dá běžně používat u referenčních typů
	- proměnná jakoby odkazuje na adresu 0 (což je ale v operačním systému neplatné mapování)
- runtimu dotnetu se říká CLR (Common Language Runtime)
- CLR u dereferencí proměnných (vlastností apod.) uvnitř proměnných referenčních typů kontroluje, jestli referenční proměnné nejsou null (tedy např. `x = null; Console.WriteLine(x.y);` vyhodí NullReferenceException)
- pokud se pokusíme vypsat null, tak Console.WriteLine automaticky vypíše prázdný řetězec a nevolá ToString (kdybychom ToString zavolali ručně, tak to při kontrole – viz výše)
- trik s rychlým překomentováním pomocí `/**/` a `/*/`
- nová sémantika referenčních typů od C# 8
	- v ReCodExu je vypnutá, ve Visual Studiu je obvykle zapnutá
	- když do zdrojáku napíšu `#nullable enable`, tak se zapne nová sémantika
	- jakmile se zapne, referenční typy nejsou nullable, je potřeba to zapínat otazníkem u každé proměnné
	- pak se můžu spolehnout na invariant, že daná proměnná nikdy nebude null
	- pokud do non-nullable referenční proměnné přiřadím null, tak to vypíše warning
		- statická analýza neumí říct stoprocentně správně, jestli je přiřazení nullu v danou chvíli špatně, takže nevrací error, ale jenom warning
- koncepční rozdíl mezi C# a Pythonem
	- Python – duck typing
		- ke kachní poště nepotřebujme kachnu, ale něco, co je kachně dostatečně podobné v těch důležitých vlastnostech
		- implicitně kódem sděluju, co potřebuju od dané proměnné
		- můžu danému kódu přiřadit cokoliv, co dané vlastnosti splňuje (kontroluje se to až za runtimu)
		- duck typing funguje i v C++ u generických typů (ale nejčastěji se objevuje v dynamicky typovaných jazycích)
	- C#
		- definuju si kontrakt
			- někdo ho implemenuje (slibuje, že má minimálně metody předepsané kontraktem)
			- někdo ho využívá (slib, že používá maximálně metody z kontraktu)
			- lze to vynucovat více způsoby, ale nejtypičtější jsou interfacy
		- interface – referenční typ
			- konvence psát na začátek názvu `I`
			- dovnitř se píšou metody / method-like věci (třeba props), nesmí tam být fields
			- jeden řádek může být např. `public int m(int a, int b);`
			- dříve muselo být všechno public, dneska je dobré tam to public explicitně psát (i když defaultně je pořád všechno public)
			- názvy parametrů metod v interfacu slouží k dokumentaci
			- nemůže existovat instance interfacu, pouze proměnná s typem interfacu (ta může být nullable)
			- `class Kachna : IPostovniZvire {…}`
			- `IPostovniZvire zvire1 = new Kachna();`
			- třída může implementovat víc interfaců
		- přístup CLR k implementaci metod
			- synovská třída dědí implementaci metody u rodiče
			- každý interface u třídy vytvoří jakoby tabulku metod, ta se zaplní reálnými implementacemi (respektive ukazateli na implementace)
			- obecně může nastat, že rodič interface neimplementuje, ale syn ano
			- tabulky jsou uloženy v instanci třídy Type (v overheadu daného objektu na haldě)
			- typ proměnné rozhoduje, jakou metodu volám
				- je to důležité při překrývání metod pomocí `new`
				- pokud je to interfacová metoda, tak záleží na tom, kam ukazuje tabulka, což vyplývá z toho, která třída implementuje interface
			- pokud chci s nějakým objektem (typicky z interfacu nebo taky u syna rodičovské třídy) zacházet speciálně podle konkrétní třídy, jejíž je instancí, můžu použít operátor `is` a pak ho castnout
				- klasický zápis: `if (a is B) {B b = (b)a; …}`
				- zkrácený zápis: `if (a is B b) {…}`
				- pokud C dědí od B, přičemž B dědí od A, pak instanci třídy C lze takto castnout do B i C (a samozřejmě i do A) – tzn. pro všechny tyto typy vrací operátor `is` hodnotu `true`
