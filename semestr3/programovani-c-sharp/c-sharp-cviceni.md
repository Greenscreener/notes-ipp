# C# cvičení

- podmínky zápočtu
	- součástí zápočťáku je dokumentace, předvedení zápočťáku může být i online
	- zápočťák se teoreticky může dělat i ve skupině, ale není to praktické
	- body navíc za kvalitní řešení domácích úkolů
	- je třeba splnit úlohu tak, aby prošly všechny testy
	- kdybychom fakt nevěděli, kde je problém, můžeme napsat Kliberovi
	- používat .NET verze 7.0
- ukládání do paměti
	- padding v lokální paměti
		- když překladač sází dvě 14B struktury vedle sebe do paměti, přičemž jejich první (vnitřní) proměnná má 8 B, tak mezi ně obvykle dá dva nulové bajty, ale struktury pořád vnímáme jako 14B (nebo jako 16B)
		- zároveň se snaží si struktury nějak přeházet, aby v paměti zabíraly co nejméně místa a vycházelo mu dobře zarovnání (podle toho, co se hodí procesoru)
	- u pole se ukládá informace o jeho délce (4 nebo 8 B), je to klasicky součástí dat (jako první je v paměti délka pole, pak jsou postupně jeho prvky)
	- struktura obsahující jeden int se v paměti ukládá stejně jako jeden int
- úkoly
	- můžeme používat knihovní funkce
	- máme si všímat společných aspektů úloh, udělat to tak, aby psaní složitější úlohy nezahrnovalo mazání kódu z jednodušší úlohy, pouze přidávání nového kódu
	- kód psát samostatně, můžeme nad úkolem společně přemýšlet a bavit se o něm
	- nepoužívat jazykové modely k psaní kódu
- řešení by mělo být
	- funkční
	- efektivní
	- „hezké“ (udržovatelné)
- nepoužívat `var` úplně všude, kde to jde
- k prvnímu úkolu
	- `File.ReadAllText(fileName) → string`
	- `File.OpenText(fileName) → StreamReader`
		- `StreamReader` obsahuje nějaký stream dat
			- lepší volat jeho konstruktor, má víc možností
		- je to potomek třídy `TextReader`
			- dá se použít s konzolí (`Console.In`)
			- dá se použít se stringem (`StringReader`)
	- obecně lepší načítat po jednom znaku než po řádcích nebo celý soubor najednou
		- `Read` vrací `int`, aby mohl dát najevo, že soubor skončil
			- takže potřebujeme rozsah 2 B (pro char) + 1 bit, tudíž 4 B
	- jak najít slova
		- `String.Split(" ", "\t") → string[]` … nic moc, vrací prázdné stringy, když je tam víc mezer
			- pozor, funkce se dá konfigurovat tak, aby do pole nedávala prázdné stringy
		- při načítání jednoho znaku můžeme dělat `string += char` nebo použít `StringBuilder` (lepší varianta)
	- očekávaná dekompozice
		- třída WordReader
			- metoda ReadWord slova posílá dál (do WordCounter nebo WordFrequencyCounter)
			- WordReader dostane zvenku nějaký TextReader
			- WordCounter/WordFrequencyCounter dostane zvenku nějaký TextWriter
		- metoda ArgumentsCheck
- v pátek se v ReCodExu objeví dvě úlohy
	- odstavcové počítání slov
		- odstavec je blok řádků, kde něco je (mezi odstavci jsou bloky prázdných řádků)
		- výstupem bude počet slov pro každý odstavec
		- definice slova zůstává stejná z minula
		- kompletní zadání bude až v pátek (do té doby se máme zamyslet nad dekompozicí)
	- sčítat, či nesčítat?
		- na každém řádku souboru stejné množství slov
		- jakoby tabulka
		- první řádek indikuje jména sloupců
		- dostaneme 3 parametry (vstup.txt vystup.txt jmeno)
		- máme vypsat součet hodnot ve sloupci označeném daným jménem
		- budeme sčítat jenom čísla, slova zatím nemusíme řešit (to pak bude v zadání)
	- když k těm úlohám dodáme integrační testy, tak dostaneme bonusové body
		- přidat soubor Tests.cs, celý ho zakomentovat (na začátek `/*`, na konec `*/`)
	- bonusové body jsou taky za kvalitu řešení
	- obecně je vhodné čtení po znacích
- objektový návrh
	- WordReader
		- WordReaderByChars nebo WordReaderByLines
		- v konstruktoru definuju stream
		- padají z něj slova
		- ty se zpracovávají
		- posílají se do WordProcessoru
	- WordProcessor
		- WordCounter
		- WordFreqCounter
		- ParaWordCounter
		- TableSummator
	- metoda ProcessAllWords
		- dám jí libovolný reader a libovolný procesor a ona bude pořád fungovat
		- to udělám pomocí interfacu
		- IWordReader
			- string? ReadWord()
				- vracíme "word" … pro slovo
				- null … pro konec souboru
				- "\\n" … pro konec řádku
					- lze použít, protože "\\n" není validní slovo
				- může být vhodné použít konstanty
					- const string EoI = null
				- ještě lepší je enum
				- takže budeme vracet strukturu Token
					- TokenType type
					- string? word
						- null bude když bude type jiný než Word
						- nebo se to dá ošetřit konstruktorem
		- IWordProcessor
			- void ProcessWord(string word)
			- void Report(TextWriter writer)
		- ale TableSummator (a ParaWordCounter taky) potřebuje informaci o konci řádku (viz ReadWord)
		- když to předěláme na tokeny, tak WordReader přejmenujeme na TokenReader…
	- vymyslet, jestli Token má být struktura nebo třída
	- vymyslet, jak udělat TokenCounter, abych do WordCounteru nemusel vrtat
	- body z ReCodExu se po odevzdání nového řešení snížit nemůžou
	- když napíšeme dost testů (aspoň třeba 10), tak můžeme dostat až 5 dalších bodů
	- když si úlohu přepracujeme podle tohohle hezčího objektového návrhu, tak se nám to může hodit k příští úloze
	- z dotazů
		- vracení boolů se hůř implementuje
		- je vhodné vyhazovat exceptions
		- je lepší si vytvořit vlastní typ exception
			- pak je v zásadě jedno, jestli se vracím různé typy nebo používám jenom message k rozlišení
- specifika recodexu
	- v recodexu dotnet 7, c# 11
	- můžeme používat global using (ale nefungují implicitní global usings)
	- funkce nullable reference types (ruší nullability referenčních typů) je defaultně vypnutá – ale funguje `#nullable enable`, takže si můžeme u každého .cs zdrojáku tuhle funkci zapnout
- Person
	- Customer
	- Employee
	- Helper
- příklad podmínky pomocí is: `person is not (Employee or Helper)`
- `public required Role Role { get; init; }`
- tři přístupy k rolím
	- každá role dědí z abstraktní třídy Person
		- je důležité vhodně označit abstraktní třídy
	- enum Role
	- třída Role
- chceme metodu, která funguje pro Employee a Helper
	- varianta 1: přetížení metody pro dva různé typy
	- varianta 2: interface
	- varianta 3: abstraktní třída PersonWithSalary, od které dědí Employee a Helper
- immutabilitu enumu zajistíme pomocí readonly
- příklad s Tokenem: `readonly record struct Token(Token Type, string? Word = null) { public Token(string word) : this(TokenType.Word, word) {} }`
- máme TokenReader, který neumí detekovat konec odstavce
	- uděláme třídu ParagraphDetectingTokenReaderDecorator
		- návrhový vzor dekorátor (wrapper)
	- bude mít metodu ReadToken, která bude používat ReadToken našeho hloupého TokenReaderu
	- když potká EndOfLine, zkusí načíst další Token a podle toho nakonec vrátí EndOfLine nebo EndOfParagraph
- když budeme chtít logovat typy tokenů, tak to budeme dělat v Mainu mezi načtením a zpracováním tokenu
	- použijeme k tomu nějakou metodu Log, která bude pravděpodobně obsahovat Console.WriteLine
	- můžeme mít konstantu `debug`
	- ještě vhodnější by mohlo být použít dekorátor DebugPrintingTokenReaderDecorator, který bude provádět logování
		- při takové implementaci můžu do dekorátoru zabalit taky původní hloupý TokenReader
- k implementaci části úkolu bychom mohli použít LLM
	- typicky u TokenReaderu
	- ale je potřeba to uvést v kódu, ideálně připojit odkaz na konverzaci s chatbotem
- jak zjišťovat, jestli znak je bílý
	- můžeme mít List znaků a použít Contains
		- O(n)
	- nebo radši HashSet, Contains
		- O(1)
		- ale hashování může být časově složité – budeme mít velkou konstantu
	- nebo taky přímo pomocí pole a funkce Array.IndexOf
		- O(n)
	- nejrychlejší (pro 3 nebo 4 whitespaces) bude asi varianta s polem
	- existuje taky metoda char.IsWhiteSpace(c), akorát té nevysvětlíme, co je whitespace
		- takže máme možná problém v zadání – řešení je zajít za zákazníkem a vysvětlit mu, že by chtěl podporovat více whitespaců
		- tahle metoda je ještě rychlejší než pole
			- indexuje do pole, kde má u každého znaku uloženy jeho vlastnosti (pro prvních asi 256 znaků)
- úloha na příště
	- na vstupu jsou slova v odstavcích (jako u počítání slov)
	- chceme přeformátovat odstavce a zarovnat je do bloku
	- na každém řádku výstupu bude právě $n$ znaků
	- narvu mezi slova mezery
	- 8 bodů za splnění zadání v ReCodExu + 3 body za 10 hezkých integračních testů (můžeme i unit testy) + 2 body, pokud první odevzdání budou testy
- co když uvnitř programu používám velká data, ale v určitou chvíli je přestanu potřebovat a chci, aby je GC zahodil
	- můžu do proměnné s odkazem na objekt přiřadit null
- když chci do stringu přidávat znaky, použiju StringBuilder
- nesmíme používat System.Linq
	- metoda Count() pro všechny kolekce spočítá prvky kolekce v lineárním čase (vs. vlastnost Count vrátí počet v konstantním čase – ale není přítomná u všech kolekcí)
- naming convention
	- metody, vlastnosti (properties), typy, veřejné fieldy – PascalCase
	- lokální proměnné, argumenty funkcí, privátní fieldy – camelCase
	- privátní fieldy (obvyklý zápis) – \_camelCase
	- interfacy – IPascalCase
	- výjimky – PascalCaseException
	- atributy – PascalCaseAttribute
	- testy – PascalCase_PascalCase_… (umožňuje rozlišování katgorií apod.)
- při opakování stringů používat konstanty
- chyby
	- zotavitelné × nezotavitelné
	- při nezotavitelné chybě se program ukončí
		- nepoužívat Environment.Exit
		- jediný správný způsob je return ve funkci Main (explicitně nebo tím, že se doběhne na konec těla funkce)
		- je vhodné se do Mainu dostat pomocí výjimky
	- zotavitelné chyby by vhodným přístupem mohla být jakási kontrolní metoda Assert
	- výjimky (vyhazování a chytání) jsou poměrně neefektivní, proto je třeba s nimi šetřit
	- typicky chceme rozlišovat mezi interní reprezentací chyby a její prezentací uživateli
		- takže rozlišujeme mezi typem výjimky a chybovou hláškou
		- např. `class InvalidFileFormatException : ApplicationException { int lineNum; }`
		- výjimkových typů v C# je hodně – základní dělení
			- bugy v programu
			- chyby uživatele – typ ApplicationException
- unit testy
	- metodu ProcessWord můžu testovat pomocí falešného WordReaderu (fake, mock, mockup)
- úkol na příště
	- rozmyslet, jak přeházet kód uvnitř TableSummatorProcessoru, aby se dal testovat
	- rozmyslet, jak ParagraphDetectingTokenReaderDecorator funguje – jak vypadají vstupní a výstupní tokeny, jak to má vlastně vypadat, napsat na to unit testy, najít chyby v Kliberově implementaci, opravit je (a nahrát do ReCodExu)
- virtual, override, abstract
	- virtual = nový záznam VMT
	- override = přepis existujícího záznamu VMT
	- abstract => virtual, ale hodnota záznamu se nastaví na `null`
- pokud má třída abstraktní metodu, musí být abstraktní
- neabstraktní potomek abstraktní třídy musí implementovat všechny abstraktní metody rodiče
- abstraktní třídy vs. interfacy
	- abstraktní třídy můžou nést data
	- u interfaců funguje vícenásobná dědičnost
- TDD (test-driven development)
	- nejdřív napíšu testy, pak dělám implementaci
	- někdy to může být vhodný přístup k psaní kódu
- úkoly na příště
	- četnost slov v souboru (druhá úloha semestru)
		- WordFrequencyCounter
		- potřebujeme si pro slovo pamatovat četnost
		- třeba přes `SortedList<string,int>`
		- nebo `SortedDictionary<string,int>`
		- nebo `Dictionary<string,int>`, posléze seřadit (vykopírovat klíče a použít Sort)
		- chceme benchmarkem zjistit, co z toho je nejrychlejší
		- použijeme Benchmark.NET
		- ke zdrojáku do komentáře máme dát tabulku, kterou nám benchmark vygeneroval
		- a napsat pár vět, co nám vyšlo, že je lepší
		- je na nás, jestli budeme mít jeden text nebo víc různých
	- druhá část úkolu, kterou je vhodné dělat nejdřív
		- pokud použijeme Dictionary
		- tři možnosti
			- zkusím ++, pokud klíč není, vyhodí se výjimka a nstavím na 1
			- ContainsKey
			- TryGetValue → value++ → = value
		- z toho mi vyjde, která varianta je nejlepší, tu budu používat v první části úkolu
- návrhový vzor adaptér
- v testech můžu jednoduchou metodu napsat jenom jednou a pak ji používat v každém testu v sekci Act
- pokud nechci pořád psát new Token(Token.EndOfLine), tak můžu použít konstanty
- unit testování table summator processor (TSP)
	- sekvence tokenů → TSP → report
	- rozdělím na části
		- sekvence tokenů → HeaderProcessor → columnCount, columnId
			- metoda ProcessToken
			- ColumnCount a ColumnId jako veřejné vlastnosti se soukromým setterem
		- sekvence tokenů, columnCount, columnId → DataColumnSummator → sum
			- ctor(int, int)
			- metoda ProcessToken
		- sum, columnId → "Reporter" → report
- benchmarkování
	- zvyšování hodnoty ve slovníku
		- když tam to slovo je
			-  vyrobíme dictionary
			- v tom benchmarku budu inkrementovat (benchmark to udělá mnohokrát)
			- poznámka: vstup do try bloku není drahý
		- když tam to slovo není
			- zařídím, aby se slovo měnilo
			- mohl bych v každém benchmarku vytvořit dictionary, použít for cyklus a volat ToString na číslo
			- ale ToString trvá dlouho
			- tak bychom si mohli připravit stringy bokem a pak je jenom vkládat
			- existují atributy `[GlobalSetup]` a `[IterationSetup]`
			- ale když použiju IterationSetup, tak se vypne opakování, takže je potřeba použít ManualConfig a nastavit tam InterationCount
	- porovnání datových struktur
		- nástroj source.dot.net na hledání ve zdrojáku
- stardew valley
	- používat anglické identifikátory – přitom volit taková slova, aby byla srozumitelná (takže IFeedable může být lepší než IFodder)
	- návrhový vzor Abstract Factory – několik Factory sdílí interface
	- návrhový vzor Strategy – Factory, která dostane jednu nebo více Factories a nějaké je používá
- domácí úkol
	- zarovnáváme do bloku více souborů
	- cílem je vyrobit jeden soubor, který bude zarovnaný do bloku
	- konec souboru odpovídá mezeře (ohraničuje slovo, ale ne odstavec)
	- máme očekávat, že vstupní soubory se generují až za běhu aplikace – při zpracovávání prvního souboru ten druhý ještě neexistuje, je potřeba ty soubory otevírat postupně
	- pokud soubor nejde otevřít, tak ho přeskočím
	- za řešení 5 bodů + 5 bodů za unit testy nové funkcionality (vícesouborového zpracování nebo zvýraznění bílých znaků nebo obojího)
	- zahrát si dyna blaster, zaměřit se na to, jaké tam jsou obrazovky (hlavně v battle módu, ale i jinde)
	- máme vyrobit graf, kde vrcholy grafu jsou různé obrazovky ve hře a hrany jsou možné přechody mezi nimi (v battle módu)
		- pro každou hranu zanalyzovat, jaká data tam tečou
		- která data jsou globální stav
		- tohle budeme odevzdávat, za pět bodů
		- specifikace přijde mailem
- úloha zarovnání do bloku
	- TextReader, z něj padají znaky do ITokenReaderu
	- ITokenReader, z něj (v Mainu) padají tokeny do ITokenProcessoru
	- z ITokenProcessoru padají seznamy stringů do BlockJustify nebo do LeftJustify
	- odtamtud se zapisuje do TextWriteru
- highlighting
	- udělám si jednodušší interface IStringWriter
	- udělám adaptér pro TextWriter
	- odekoruju
- více souborů
	- MultiSourceTokenReader
	- factory na TokenReader
	- MultiSourceTokenReader přijme seznam tokenReaderFactories
- dynablaster
	- screenshoty obrazovek jsou hezké
	- když je nemám, tak si je načrtnu
	- neplést do toho imlementaci v C#
	- některé přechody se dějí samy od sebe
- objektový návrh
	- Screen
		- vstup: klávesy
		- výstup: data (výběr herního režimu apod.)
	- MainController
		- currentScreen
		- pamatuje si graf obrazovek a řeší přechody
		- screen1.Deactivate, screen2.Activate
		- vstup: klávesy
		- klávesy předává obrazovce
		- obrazovka komunikuje s Controllerem
	- BattleConfigController
	- MatchController
	- BattleConfig
	- MatchStats
- návrhový vzor MVC (Model – View – Controller)
	- Model … data
	- View … obrazovka
	- Controller … stará se o zobrazování Views a předávání dat
	- někdy View zprostředkovává uživatelský vstup a předává o tom informaci Controlleru
- vyděláváme peníze
	- potřebujeme nápad
		- prodávání knížek
		- vyrobíme internetové knihkupectví
	- zvučné jméno
		- dobrá knihkupectví se jmenují podle řek
		- Nežárka
	- doména – nezarka.net
	- zaregistrovat + zaplatit doménu
	- design
	- specifikace – v ReCodExu
	- implementace
	- ?
	- profit
- implementace
	- na vstupu dostaneme model
	- budou chodit „requesty“ (taky dostaneme na vstupu)
	- pro každý request vypsat HTML (dohromady na výstupu)
	- náš obchod by měl být rozšiřitelný (ne na úplně jiný obchod)
	- počet obrazovek se bude rozšiřovat
	- máme použít MVC
	- máme vyrobit C# kód, který HTML tiskne
	- konverzi HTML do C# kódu máme nějak automatizovat

---

- všechno v C# se defaultně předává hodnotou (ta hodnota může být i adresa)
- je vhodné na netriviální část zadání napsat unit testy
- za unit testy jsou bonusové body
- to, že něco chybí, se z kódu vykoukat nedá
- klíčové slovo `partial` nám umožňuje rozdělit třídu do dvou souborů
	- není to dobrý nápad – kód pak může divně interagovat, když si nedáme pozor při psaní (kvůli scopu/namespacu)
- Nežárka – implementace
	- načtení modelu
	- přečtení requestu
	- parsování requestu
	- zpracování requestu
		- modifikace modelu
		- výběr podmnožiny modelu
	- zobrazení modelu
- dává smysl rozdělit controller, mít MasterController, BooksController a ShoppingCartController
- při testování můžu nafejkovat BooksController a ShoppingCartController a jenom testovat, jestli se na nich volají správné funkce (když chci testovat parsování requestů)
- dává smysl mít model staticky globálně?
	- možná jo
	- ale může být užitečné být schopný řešit situaci, kdy je modelů víc
- opakované stringy dává smysl vytáhnout do konstant
- dává smysl, aby implementace práce s daty byla v modelu
	- pozn.: když přidávám knížku do košíku, tak bych měl asi přidávat `Book book`, ne `int bookId`
- parametrizace view pro účely testování nebo přepínání formátů (HTML, JSON, …)
	- pomocí factory
- úkol na příště
	- kódovací algoritmus Huffman
	- úloha bude mít dvě až tři části
	- binární soubor – řešíme bajty
	- stavíme binární strom
	- je důležité rozlišovat, který vrchol patří doleva a který doprava
	- strom procházíme v prefixovém pořadí
	- je potřeba ten strom opravdu postavit v paměti – nestačí ho vypsat
	- triviální integrační test – podívat se na číslo v kořeni (bude tam velikost souboru)
	- cílem je používat O(1) paměti
