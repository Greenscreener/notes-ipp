# Počítačové systémy

- …
- ABI (…)
- MIPS registry – jejich účely (jak by se měly používat) jsou popsány v MIPSovém ABI
	- je lepší používat přímo jména registrů v ABI – aby případné přečíslování registrů nedělalo problém
	- různé funkce registrů (…)
- základní instrukce
	- součet dvou registrů, uložení do (třetího) registru
		- na rozdíl od x86 umí MIPS uložit výsledek do třetího registru
	- přičtení 16bit. konstanty k registru, uložení do registru
	- podobně rozdíl, odečtení konstanty
	- logické operace – and, or, xor, nor (or + negace)
	- negace se dělá pomocí `nor $t1,$t2,$t2`
	- bitové posuny
	- přístup do paměti
- (5. přednáška)
- MIPS instrukce
	- nepodmíněné skoky
		- na adresu (j)
		- skok přes obsah registru (jr)
		- jump and link (jal; pro uložení návratové adresy do registru 31 a skok do podprogramu – návrat pomocí jr 31; kdybychom chtěli skákat do vnořených funkcí, tak bychom potřebovali zásobník)
	- podmíněné skoky – equal, not equal (beq, bne)
	- porovnávání – slt (menší než), sltu (unsigned), slti (immediate), sltiu
		- na x86 pomocí odčítání a příznaků
	- `lw $t0, 4($gp)` načte hodnotu z místa, kde jsou v paměti globální proměnné, offset 4
	- násobení (malými čísly) se převádí na sčítání pomocí binárního rozkladu
- příznaky na x86
	- rezervované, systémové, aritmetické
	- typicky se používá zero flag (1 když u poslední operace vyšla nula), sign flag (kopie MSb znaménkového čísla), carry flag (přetečení a podtečení v bezznaménkové aritmetice)
- ISA – shrnutí
	- ISA je abstraktní model, často může být odtržený od implementace
	- u x86 architekturu vlastní společně Intel a AMD
	- tradiční klasifikace
		- CISC – Complex Instruction Set Computer
			- lidi píšou programy v asembleru
		- RISC – Reduced…
			- překládám program překladačem z vyššího programovacího jazyka
			- např. x86 (původně)
		- VLIW – Very Long Instruction Word
			- není potřeba dekódovat instrukci, rovnou je z ní jasné, co mají které části procesoru dělat
		- EPIC – Explicitly Parallel Instruction Computer
			- v jedné instrukci je jich několik (?)
	- ortogonalita – mám obecné registry a instrukce, které můžu používat s libovolnými registry (x86 není ortogonální; obecně akumulátorové instrukční sady nejsou ortogonální)
	- architektura typu Load-Execute-Store – máme zvlášť instrukce na load a store, s pamětí nejde dělat nic jiného
- hardwarová architektura
	- procesor
		- řadič paměti
		- cache
		- jádra – logické procesory + registry
	- hyper-threading – na jedné výpočetní jednotce (uvnitř jádra) běží dvě instrukce najednou
		- uvnitř jednoho jádra jsou dvě vlákna (logické procesory) – může jich být i víc
		- zvyšuje to výkon, schovává to latenci přístupu do paměti
		- každé vlákno má své registry
	- hierarchie keší
		- privátní (na každém jádru)
			- L1I a L1D – malé keše
			- L2 – větší, pro kód (instrukce) i data
		- sdílená
			- L3/LLC – velká; dneska má obvykle každé jádro vlastní L3\$ slice
	- 95 % přístupů do paměti jde z nějaké úrovně cache (což je fajn, protože paměť je pomalá)
	- out-of-order execution – instrukce si procesor popřehází, aby to bylo rychlejší (ale výsledek odpovídá tomu, jako by je vykonával ve správném pořadí)
- pipeline
	- jednotlivé kroky (stage) jedné instrukce: načtení instrukce z paměti, její dekódování, vykonání, paměťová operace, zápis výsledku do registru
	- najednou se můžou vykonávat všechny kroky instrukce (takže vlákno v jednu chvíli zpracovává pět instrukcí – u každé z nich je v jiné stagi)
	- je potřeba řešit správné pořadí zápisů a načtení dat
	- problém s podmíněnými skoky – ve chvíli, kdy zjistím, že mám skákat, už bych vykonával stage u dalších instrukcí
		- používá se branch predictor, zkouší odhadnout, kam se skočí
		- když to odhadne špatně, tak se pipeline restartuje
		- hledá ve skákání nějaké vzory, zkouší hádat
		- pokud instrukci na dané adrese nikdy neviděl, tak zpětný skok předpokládá, naopak dopředný skok nikoliv
- superskalární procesor
	- jsme schopni souběžně zpracovávat více instrukcí
	- dnešní procesory jsou pěticestné – najednou zpracovávají pět instrukcí
	- dnes se používá asymetrická superskalarita – jedna pipeline je silnější a zvládá všechno, čtyři zbývající jsou slabší a zvládají jenom jednoduché instrukce
- out-of-order execution
	- mikroinstrukce se umístí do poolu a čekají, až budou mít výkonné jednotky volno
	- jednotlivé jednotky umí různé věci

## Paměť

- podle rychlosti: registry, cache, RAM, perzistentní RAM, SSD + flash disky, HDD, magnetické pásky
	- od perzistentní RAM (včetně) ta média drží data po vypnutí
	- po perzistentní RAM (včetně) jsou uložená data přístupná CPU, zbytek je obsluhován vždy nějakým řadičem (jako externí I/O)
- paměť – definice
	- každá paměť se skládá z paměťových buněk – bitů
	- bity jsou seskupeny do slov fixní délky
	- každé slovo je přístupné binární adresou (podle délky adresy rozlišujeme např. 32 nebo 64bitovou architekturu)
		- můžeme uložit $2^N$ slov, kde $N$ je délka adresy
	- dnes se používá 8bitové slovo (bajt)
- fyzický pohled na paměť
	- paměť je vlastně dvojrozměrná
	- adresa se dekóduje tak, aby paměťový řadič našel správnou řádku a sloupec v ní
	- když bajty jsou za sebou, jsou v jedné řádce
	- časování
		- CAS – Column Access Strobe, kolik taktů trvá, než jsem schopný adresovat další sloupec uvnitř jedné řádky (tento parametr ovlivňuje cenu paměti)
		- další 3 parametry
- datová reprezentace
	- celá čísla
		- bezznaménková
			- jednoduchá binární reprezentace čísla
			- obvykle 1, 2, 4, 8 bytů
			- reprezentovaný rozsah $[0;2^N-1]$
		- znaménková
			- dvojkový doplněk
			- bitová negace + 1
			- pouze jedna 0
			- kompatibilní s bezznaménkovou aritmetikou
			- asymetrický rozsah $[-2^{N-1};2^{N-1}-1]$
			- MSb určuje znaménko čísla
	- desetinná čísla – float
		- $\text{value}=(-1)^{\text{sign}}\cdot\text{significand}\cdot 2^{\text{exponent}-\text{bias}}$
		- tohle je reprezentace v paměti, procesory si to ukládají po svém
- endianita – vícebytová čísla se v paměti ukládají tak, že je MSB na začátku (big endian), nebo LSB na začátku (little endian)
- zarovnání dat
	- moderní procesory vyžadují, aby byla data v paměti zarovnaná podle jejich velikosti
	- např. 4bajtový int musí mít adresu zarovnanou na 4 (dělitelnou čtyřmi)
	- celá struktura (struct) je zarovnaná na největší datový typ dostupný na CPU (např. 16B)
	- některé jazyky přehazují položky ve struktuře, aby se eliminovalo volné místo
	- sizeof vrátí velikost včetně těch mezer 
- správa paměti
	- globální proměnné – přiřazena na začátku, celou dobu drží svoji hodnotu, je na jednom místě v paměti
	- lokální proměnné, argumenty funkcí – uloženy na zásobníku
	- dynamicky alokované proměnné – programátor je explicitně alokuje (pomocí `malloc()`, `new`, `unique_ptr`, …), existuje vyhrazený blok paměti pro tyto alokace
- alokace paměti
	- úkol – najdi blok nepoužité paměti dostatečné velikosti, alokuj část velkého poolu paměti (používá se pojem heap)
	- životní cyklus – alokuj blok, použij blok, uvolni blok
	- vždy existuje určitý počet bytů, který lze minimálně alokovat – takže na jednobytovou proměnnou se alokuje zbytečně moc paměti (proto není dobré příliš používat `new`)
- fragmentace
	- interní – v bloku je alokováno více paměti, než je potřeba
	- externí – volná paměť je rozdělena do malých bloků a mezi nimi jsou bloky alokované paměti
- dynamická alokace paměti – mám spojový seznam volných bloků nebo bitmapu (kde každý bit reprezentuje jeden blok)
- alokační algoritmy
	- first fit – začíná na začátku, najde první dostatečně velké volné místo
	- next fit – stejné jako first fit, akorát začíná na pozici, kde bylo alokováno naposledy
	- best fit – začíná na začátku, najde nejmenší dost velké volné místo
		- vytváří malinké díry
	- worst fit – začíná na začátku, najde největší místo
- cvičení na alokaci – alokuju do 64B bloků
	- alokuju A, což je 42 B, nejbližší násobek je 64 B
	- 2 KiB je násobek 64 B, alokuju za A
	- 100 B – alokuju 128 B
	- atd.
	- pak dealokuju nějaké bloky
	- alokuju dál pomocí nějaké metody – podle toho se bloky alokují na nějaké místo
- buddy memory allocation
	- bloky velikosti $2^N$, adresy zarovnány na násobek své velikosti
	- hledám nejmenší volný blok, který odpovídá požadované velikosti
	- když je blok moc velký, tak ho rozpůlím
- cache
	- hardwarová nebo softwarová struktura, v níž jsou uložena data, aby se zrychlily operace s nimi
	- velikost cache je omezená
	- CPU používá cache, aby zrychlil přístup do paměti (když má data uložená v cachi, nechodí pro ně do paměti)
	- cache je tvořena jednotlivými řádky (obvykle mají 64 bajtů, jsou zarovnány)
	- cache hit – požadavek je odbaven z cache
	- cache miss
		- data nebyla nalezena v hierarchii cache
		- provádí se přístup do paměti
		- načtená data se ukládají do cache
		- pokud není volná cache line, uloží se na místo jiné cache
			- tato původní cache se propisuje do hlavní paměti (při zapisování dat totiž procesor zapisuje do cache)
	- stav cache line se udržuje pomocí MESI protokolu
	- technická realizace cache = asociativní paměť
		- je to v podstatě tabulka – vlevo klíč (odpovídající adresa v paměti), vpravo hodnota (cache line)
		- konstantně rychle se v ní hledá klíč
		- rychlost se zajišťuje hardwarově
- víceprocesorový systém
	- SMP – symetrický multiprocessing
		- všechny procesory přistupují do paměti přes systémovou sběrnici
		- přístupy jsou stejně rychlé
	- NUMA – non-uniform memory access
		- každý procesor má „svůj“ blok paměti
		- jeden společný adresový prostor vzniklý sloučením bloků jednotlivých pamětí
		- každý procesor může adresovat libovolnou paměť
		- přístupy jsou různě rychlé – přístupy do „cizích“ pamětí trvají déle

## Programovací jazyky

- překladač, gramatika
- překlad
	- preprocesor
	- kompilátor (překladač)
	- assembler
	- linker
- knihovna – statická nebo dynamická sada binárek
- linking – spojení binárek do jedné
- loader – načte program do paměti
- program vs. proces (proces je spuštěný program, entita operačního systému)
- knihovna se linkuje do souboru .lib (statická knihovna)
	- lidi už pak používají přímo hlavičkový soubor a statickou zkompilovanou knihovnu
	- pokud je knihovna statická, použije ji linker, pokud je dynamická, použije ji až loader
- organizace paměti
	- u toho procesu musí OS nějak řešit paměť
	- překladač jednotlivé části programu dává do správných segmentů
		- příklady segmentů – globální proměnné, konstanty, instrukce…
	- v paměti je kód, statická data, zásobník (vzájemné volání funkcí, lokální proměnné) a halda (na dynamickou alokaci proměnných)
	- realističtěji – kód, konstanty, inicializovaná statická data (např. `int x = 5;`, konkrétní hodnoty jsou umístěny ve spustitelném souboru), neinicializovaná statická data (např. objekty – konstruktor se volá až při běhu programu), jeden zásobník pro každé vlákno (při rekurzi může dojít), halda
- linking
	- linker vezme segmenty z každého souboru a slije je dohromady
	- z knihovny do výsledného souboru skládá jenom ty funkce, které jsou opravdu použity
	- linker přepočítává adresy na základě toho, jak za sebe skládá segmenty (začátek segmentu je na adrese 0)
	- loader pak ty adresy po spuštění přepočítává znova podle toho, kde jsou segmenty uloženy v paměti
- volací konvence
	- každá funkce má na zásobníku aktivační záznam
	- na zásobník uložím (z registrů) návratovou adresu a adresu aktivačního záznamu funkce, která mě volala
	- některé další registry (které mají vlastnost Preserve) uložím do zásobníku, aby nebyly poškozeny
	- volací konvence jasně deklaruje, jak se hodnoty předávají z volané funkce do volající
	- volající funkce připraví na zásobníku prostor (strukturu) pro vrácenou hodnotu, překladač adresu této struktury předá volané funkci jako parametr
	- relativní adresace lokálních dat a dočasných proměnných – adresy se počítají relativně vůči frame pointeru
	- technologie linkeru a loaderu je stará a nepočítala s přetížením funkcí – proto se dělá public name mangling (do jmen funkcí se vkládá otisk typů a jmen parametrů)
	- musí být jasně definované, co každá funkce uklízí
	- parametry fungují v podstatě stejně jako lokální proměnné
	- předávání parametrů
		- předání hodnotou – na zásobník dám kopii vypočítané hodnoty parametru
		- předání referencí – na zásobník dám ukazatel (adresu) na parametr
			- v C se všechny parametry předávají hodnotou, takže se vlastně pointery kopírují
- proměnné
	- proměnná = pojmenovaný kus paměti, v němž je uložena hodnota; má typ
	- způsob uložení
		- statická data – globální proměnné v C
		- zásobník – lokální proměnné v C
		- halda – dynamická paměť v C/C#
	- slovník (Python, PHP, JavaScript)
		- dynamická struktura
- halda
	- úložiště pro dynamickou paměť
	- alokace – vedeme si evidenci volných bloků, používá se nějaký ze zmíněných algoritmů
		- alternativní přístup – inkrementální alokace, vycházíme z předpokladu, že paměť nedojde
	- dealokace – někde explicitní (C, C++), jinde automatická pomocí garbage collectoru
		- když přijdu o pointer na objekt v paměti (takže ho nemůžu smazat) = memory leak
		- u explicitní dealokace se používá funkce free – může být problém, pokud ji na jeden objekt voláme víckrát
		- GC se spustí, jakmile dojde paměť
		- při běhu garbage collectoru se může běh programu úplně zaseknout
		- přístupy k GC
			- tracing – procházíme všechny živé objekty a hledáme, co je z nich dosažitelné
			- reference counting
- přenositelnost kódu
	- může se lišit velikost typů na různých architekturách (u některých jazyků)
	- někdy může hrát roli i endianita
	- některé překladače mají specifické funkce (nebo syntaxi) navíc – ty není dobrý nápad používat
	- volání funkcí OS přímo pomocí příkazů (někdy to není problém, pokud OS používají stejnou knihovnu)
	- přenositelnost se někdy řeší pomocí virtuálního stoje (VM)
		- C#, Java
		- program se přeloží do bytecodu (Java) nebo CIL (C#)
		- jsou to „instrukce procesoru, který neexistuje“
		- pak je tam běhová podpora, která zpracovává instrukce abstraktního procesoru a vykonává instrukce toho konkrétního procesoru, na kterém běží – tenhle přístup je extrémně pomalý
		- výhoda: lze to zavřít do sandboxu
		- řešení problémů s rychlostí
			- JIT (just in time) kompilace – překládá mezikód do nativního kódu na vyžádání, pokud daný překlad ještě neexistuje
			- AOT (ahead of time) kompilace – při instalaci program přeložím do nativního kódu (používá se třeba u Androidu)

## Operační systém

- role OS
	- abstraktní stroj
		- je reprezentován rozhraním jádra
		- schovává komplexitu hardwaru
	- správa zdrojů
		- management hardwaru zajišťuje OS
		- sdílení HW mezi aplikacemi
			- alokace paměti
			- procesorový čas
			- abstrakce (disk, síť)
- režimy procesoru (bývá jich několik, ale nejdůležitější jsou dva)
	- uživatelský režim
		- přístupný všem aplikacím
		- omezený přístup ke zdrojům
	- kernel mode
		- je používán operačním systémem nebo jeho částí
		- má plný přístup ke zdrojům
	- přechod mezi režimy je jasně definovaný – je pouze omezené množství způsobů, jak přepnout z uživatelského do kernel režimu (aby bylo možné vyhodnotit, zda je to záměr, nebo chyba)
		- syscall = volání systémového API
		- tenká vrstva nad OS zajišťuje syscally
- architektura
	- monolitická
		- obslužná vrstva, jejím prostřednictvím se volají interní funkce
		- takhle funguje linuxový kernel
		- zranitelnost – programy v jádře mohou dělat cokoliv
		- původně byly součásti jádra pevně nastavené od instalaci
			- problém – při připojení klávesnice chceme nainstalovat driver zařízení -> dnes lze obsah jádra měnit
	- vrstvená
		- každá vrstva má svoje rozhraní
		- každá vrstva může používat jenom vrstvu přímo pod ní (její rozhraní)
	- mikrokernel
		- většina služeb se z kernel space vystrčí do user space, jsou tam jako jednotlivé moduly, ty komunikují bez sebou a s jádrem
		- je to rozšiřitelné, spolehlivé (jednotlivé služby lze v případě chyby restartovat) a bezpečné, ale poměrně pomalé
		- takhle fungují Windows
			- mají ještě hardwarovou abstrakční vrstvu, takže mikrokernel je přenositelný
			- služby běží v kernel režimu (což je v rozporu s filozofií mikrokernel)
- zařízení
	- pojmy
		- řadič zařízení (controller) – HW součástka, komunikuje se zařízením nějakým protokolem
		- ovladač zařízení (driver) – SW komoponenta, součást operačního systému, realizuje komunikaci s řadičem, poskytuje operačnímu systému jednotné komunikační zařízení
		- BIOS/UEFI – inicializuje zařízení při bootu
	- topologie zařízení
		- sběrnice
			- řadič, z něj vychází jeden drát, na něj jsou všechna zařízení připojena
			- na jedné sběrnici je přetlak
			- při paralelním vedení drátů je problém s přeslechy (vzájemné rušení signálů)
		- hvězda
			- každé zařízení je připojeno k řadiči samostatně
			- takhle funguje SATA
			- nevýhoda – na řadiči musí být víc konektorů
			- výhoda – na drátu není nikdo jiný, takže není potřeba řešit adresaci
			- používají se sériové protokoly – jsou rychlejší než paralelní
		- ring
			- signál se po kruhu pohybuje jedním směrem – každé zařízení (i řadič) jedním portem vysílá a druhým přijímá
		- strom
			- k řadiči můžu připojit rozbočovač (hub)
			- takhle funguje USB
	- jak CPU provádí I/O operace
		- buď má speciální instrukce, nebo používá memory-mapping
	- uživatel chce nějaké množství dat – jejich získání zajišťuje kernel/řadič (může být potřeba několik dotazů)
	- komunikace se zařízeními
		- polling – CPU se aktivně ptá na změnu stavu zařízení (pomalé, dnes už se nepoužívá)
		- přerušení – řadič vyšle signál, že je operace hotová, a přeruší chod procesoru (ale pořád musím kopírovat data, což je pomalé)
		- DMA (Direct Memory Access) – přenos dat ze zařízení do paměti probíhá hardwarově bez účasti procesoru, až pak se provede přerušení; funkce scatter/gather umožňuje využívat nesouvislé části paměti
	- typy přerušení
		- externí – hardwarové pomocí IRQ pinu, lze ho zamaskovat (deaktivovat – pomocí registru)
		- (hardwarová) výjimka – nastal problém s instrukcemi -> procesor vyvolá přerušení a nechá na OS, aby situaci vyřešil
			- výjimka typu trap se volá po instrukci, např. dělení nulou
			- u výjimek typu fault se procesor vrátí na stav před instrukcí, nechám OS, aby problém opravil, a potom instrukci pustím znova
		- softwarové – speciální instrukce
	- jak funguje přerušení
		- CPU zjistí zdroj přerušení
		- získá adresu handleru
		- proud instrukcí je přerušen
		- handler uloží stav CPU
		- handler udělá něco užitečného
		- handler obnoví stav CPU
		- CPU pokračuje v proudu instrukcí
- program = pasivní soubor na disku
- loader – vezme program a načte ho do paměti
- někde v hlavičce programu je informace o tom, kde program (výkon instrukcí) začíná
- proces
	- instance programu vytvořená operačním systémem
	- je to datová struktura uvnitř operačního systému, v níž jsou uložené různá data, která daný program potřebuje
	- vlastní: kód, prostor v paměti, další prostředky
- vlákno (thread)
	- místo uvnitř procesu, kde se vykonávají instrukce
	- kontext procesoru – datová struktura, ve které jsou uložené registry procesoru, pokud dané vlákno zrovna neběží
	- vlastní: pozici v kódu (program counter), svůj zásobník, stav procesoru
- fiber
	- lightweight vlákno
	- nemá celý kontext
	- scheduling se dělá kooperativně (jednotlivé fibery se vzájemně vyměňují v běhu)
- scheduler – část operačního systému, používá schedulingové algoritmy k přidělení zdrojů (jader) jednotkám
- když se přeruší vykonávání vlákna, provede se context switch – kontext procesoru se uloží
- real-time scheduling: real-time proces má čas, kdy se má spustit, a čas, do kdy má skončit (hard deadline – nemá smysl pokračovat, soft deadline – má smysl pokračovat ve výpočtu)
- stavy vlákna
	- created
	- ready
	- running
	- blocked
	- terminated (zombie)
- multitasking
	- cooperative – všechny procesy kooperují, předávají si řízení
	- preemptive – každé vlákno dostane od scheduleru svůj time slice; jakmile čas vyprší, dojde k přerušení
- scheduling
	- cíle
		- …
	- priorita – vázaná na proces
		- je dvousložková – při spuštění se přiděluje statická priorita (podle uživatele), dynamická priorita se v časových intervalech pravidelně zvyšuje všem ready vláknům (po spuštění se dynamická priorita sníží na nula); celková priorita je daná součtem
	- kooperativní algoritmy
		- first come, first serve (FCFS)
			- FIFO řada, procesy se vykonávají v pořadí, ve kterém přišly
		- shortest job first
			- musí být známý očekávaný čas běhu
		- longest job first
	- preemptivní algoritmy
		- round robin
			- jako FCFS
			- když vlákno trvá moc dlouho, tak se zařadí na konec fronty
		- multilevel feedback-queue
			- každá fronta má jinak dlouhý time slice
			- první (horní) ho má kratší, ty pod ní ho mají delší
			- když vlákno trvá moc dlouho, tak se zařadí na konec nižší fronty
			- když se vlákno brzo zablokuje, tak se zařadí na konec vyšší fronty
		- completely fair scheduler (CFS)
			- používá červeno-černý strom
- komunikace mezi procesy (inter-process communication = IPC)
	- kooperující procesy – jejich zdroje jsou izolovány operačním systémem, ke komunikaci používají OS-specifické IPC API
	- typické IPC metody
		- pipes (nebo jiný typ socketů)
		- sdílená paměť
		- signály
- soubor
	- jednotka organizace dat
	- kolekce souvisejících informací
	- jádro OS nerozumí formátům souborů
	- soubory se typicky neukládají v paměti, ale na perzistentním úložišti
	- soubor je chápán jako unikátní číslo – kvůli lidem mají soubory jméno a cestu (aby v souborech nebyl chaos)
	- některé části názvu souboru (počáteční tečka, přípona) mají speciální význam (ale přípona souboru nemusí souviset s reálným formátem souboru)
	- operace se soubory – vyčištění cache, změna atributů, vytvoření, smazání
	- file handle – číslo specifické pro proces, odkazuje na konkrétní soubor (stdin, stdout, stderr mají handles 0, 1, 2)
	- buffering
		- cachování sektorů disku (když disk čtu po bajtech, první se načítá z cache, všechny ostatní v daném sektoru už se pak načítají z cache)
		- existuje několik úrovní cache (systémová, language runtime)
		- sekvenční vs. náhodný přístup
	- alternativy – memory mapping, asynchronní přístup souborům
- adresář
	- kolekce souborů
	- význam – rychlejší hledání souboru, lepší navigace pro uživatele, logické seskupení souborů
	- obvykle reprezentován jako soubor
	- někdy v něm můžou být uloženy některé atributy jeho souborů
	- obvykle existuje kořenový adresář
	- operace – vytvořit, smazat, přejmenovat, najít název, vypsat soubory
- ukládání souborů
	- tradiční úložiště
		- na sekundárním nebo externím úložišti
		- file system in RAM (pro dočasné soubory)
	- síťové úložiště – soubory se tváří, jako by byly na disku, ale přitom jsou uloženy někde jinde na síti
	- virtuální soubory – např. /dev/null
- file links
	- links (hard links)
		- více adresářových záznamů odkazuje na stejný fyzický soubor
		- většina operací je transparentních
		- šetří místo, ale může dělat problémy (smazání hardlinku nesmí smazat fyzický soubor – takže OS musí počítat odkazy na daný soubor)
	- symlinks (soft links)
		- symlinky jsou speciální soubory, v nichž je uložená cesta jiného souboru
- file system
	- řeší překlad jmen, správu datových bloků, správu dat souborů
	- pro file system je jednotkou jeden blok, blok je určitý počet sektorů
	- řeší abstrakci práce se soubory a adresáři
	- může být lokální (FAT, NTFS) nebo síťový (NFS, CIFS/SMB)
	- práce s FAT bude u zkoušky :)
- File Allocation Table (FAT)
	- z doby MS DOSu
	- jedna struktura (FAT) spravuje volné bloky a uložení dat souborů (a asi i názvy souborů?)
	- adresář je sekvence záznamů s pevnou délkou a atributy
	- root je na fixní pozici
	- formát struktury
		- boot record
		- FAT1
		- FAT2
		- root directory
		- data
	- 