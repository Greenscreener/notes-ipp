# Počítačové systémy

- …
- ABI (…)
- MIPS registry – jejich účely (jak by se měly používat) jsou popsány v MIPSovém ABI
	- je lepší používat přímo jména registrů v ABI – aby případné přečíslování registrů nedělalo problém
	- různé funkce registrů (…)
- základní instrukce
	- součet dvou registrů, uložení do (třetího) registru
		- na rozdíl od x86 umí MIPS uložit výsledek do třetího registru
	- přičtení 16bit. konstanty k registru, uložení do registru
	- podobně rozdíl, odečtení konstanty
	- logické operace – and, or, xor, nor (or + negace)
	- negace se dělá pomocí `nor $t1,$t2,$t2`
	- bitové posuny
	- přístup do paměti
- (5. přednáška)
- MIPS instrukce
	- nepodmíněné skoky
		- na adresu (j)
		- skok přes obsah registru (jr)
		- jump and link (jal; pro uložení návratové adresy do registru 31 a skok do podprogramu – návrat pomocí jr 31; kdybychom chtěli skákat do vnořených funkcí, tak bychom potřebovali zásobník)
	- podmíněné skoky – equal, not equal (beq, bne)
	- porovnávání – slt (menší než), sltu (unsigned), slti (immediate), sltiu
		- na x86 pomocí odčítání a příznaků
	- `lw $t0, 4($gp)` načte hodnotu z místa, kde jsou v paměti globální proměnné, offset 4
	- násobení (malými čísly) se převádí na sčítání pomocí binárního rozkladu
- příznaky na x86
	- rezervované, systémové, aritmetické
	- typicky se používá zero flag (1 když u poslední operace vyšla nula), sign flag (kopie MSb znaménkového čísla), carry flag (přetečení a podtečení v bezznaménkové aritmetice)
- ISA – shrnutí
	- ISA je abstraktní model, často může být odtržený od implementace
	- u x86 architekturu vlastní společně Intel a AMD
	- tradiční klasifikace
		- CISC – Complex Instruction Set Computer
			- lidi píšou programy v asembleru
		- RISC – Reduced…
			- překládám program překladačem z vyššího programovacího jazyka
			- např. x86 (původně)
		- VLIW – Very Long Instruction Word
			- není potřeba dekódovat instrukci, rovnou je z ní jasné, co mají které části procesoru dělat
		- EPIC – Explicitly Parallel Instruction Computer
			- v jedné instrukci je jich několik (?)
	- ortogonalita – mám obecné registry a instrukce, které můžu používat s libovolnými registry (x86 není ortogonální; obecně akumulátorové instrukční sady nejsou ortogonální)
	- architektura typu Load-Execute-Store – máme zvlášť instrukce na load a store, s pamětí nejde dělat nic jiného
- hardwarová architektura
	- procesor
		- řadič paměti
		- cache
		- jádra – logické procesory + registry
	- hyper-threading – na jedné výpočetní jednotce (uvnitř jádra) běží dvě instrukce najednou
		- uvnitř jednoho jádra jsou dvě vlákna (logické procesory) – může jich být i víc
		- zvyšuje to výkon, schovává to latenci přístupu do paměti
		- každé vlákno má své registry
	- hierarchie keší
		- privátní (na každém jádru)
			- L1I a L1D – malé keše
			- L2 – větší, pro kód (instrukce) i data
		- sdílená
			- L3/LLC – velká; dneska má obvykle každé jádro vlastní L3\$ slice
	- 95 % přístupů do paměti jde z nějaké úrovně cache (což je fajn, protože paměť je pomalá)
	- out-of-order execution – instrukce si procesor popřehází, aby to bylo rychlejší (ale výsledek odpovídá tomu, jako by je vykonával ve správném pořadí)
- pipeline
	- jednotlivé kroky (stage) jedné instrukce: načtení instrukce z paměti, její dekódování, vykonání, paměťová operace, zápis výsledku do registru
	- najednou se můžou vykonávat všechny kroky instrukce (takže vlákno v jednu chvíli zpracovává pět instrukcí – u každé z nich je v jiné stagi)
	- je potřeba řešit správné pořadí zápisů a načtení dat
	- problém s podmíněnými skoky – ve chvíli, kdy zjistím, že mám skákat, už bych vykonával stage u dalších instrukcí
		- používá se branch predictor, zkouší odhadnout, kam se skočí
		- když to odhadne špatně, tak se pipeline restartuje
		- hledá ve skákání nějaké vzory, zkouší hádat
		- pokud instrukci na dané adrese nikdy neviděl, tak zpětný skok předpokládá, naopak dopředný skok nikoliv