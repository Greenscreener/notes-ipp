# Počítačové systémy

- …
- ABI (…)
- MIPS registry – jejich účely (jak by se měly používat) jsou popsány v MIPSovém ABI
	- je lepší používat přímo jména registrů v ABI – aby případné přečíslování registrů nedělalo problém
	- různé funkce registrů (…)
- základní instrukce
	- součet dvou registrů, uložení do (třetího) registru
		- na rozdíl od x86 umí MIPS uložit výsledek do třetího registru
	- přičtení 16bit. konstanty k registru, uložení do registru
	- podobně rozdíl, odečtení konstanty
	- logické operace – and, or, xor, nor (or + negace)
	- negace se dělá pomocí `nor $t1,$t2,$t2`
	- bitové posuny
	- přístup do paměti
- (5. přednáška)
- MIPS instrukce
	- nepodmíněné skoky
		- na adresu (j)
		- skok přes obsah registru (jr)
		- jump and link (jal; pro uložení návratové adresy do registru 31 a skok do podprogramu – návrat pomocí jr 31; kdybychom chtěli skákat do vnořených funkcí, tak bychom potřebovali zásobník)
	- podmíněné skoky – equal, not equal (beq, bne)
	- porovnávání – slt (menší než), sltu (unsigned), slti (immediate), sltiu
		- na x86 pomocí odčítání a příznaků
	- `lw $t0, 4($gp)` načte hodnotu z místa, kde jsou v paměti globální proměnné, offset 4
	- násobení (malými čísly) se převádí na sčítání pomocí binárního rozkladu
- příznaky na x86
	- rezervované, systémové, aritmetické
	- typicky se používá zero flag (1 když u poslední operace vyšla nula), sign flag (kopie MSb znaménkového čísla), carry flag (přetečení a podtečení v bezznaménkové aritmetice)
- ISA – shrnutí
	- ISA je abstraktní model, často může být odtržený od implementace
	- u x86 architekturu vlastní společně Intel a AMD
	- tradiční klasifikace
		- CISC – Complex Instruction Set Computer
			- lidi píšou programy v asembleru
		- RISC – Reduced…
			- překládám program překladačem z vyššího programovacího jazyka
			- např. x86 (původně)
		- VLIW – Very Long Instruction Word
			- není potřeba dekódovat instrukci, rovnou je z ní jasné, co mají které části procesoru dělat
		- EPIC – Explicitly Parallel Instruction Computer
			- v jedné instrukci je jich několik (?)
	- ortogonalita – mám obecné registry a instrukce, které můžu používat s libovolnými registry (x86 není ortogonální; obecně akumulátorové instrukční sady nejsou ortogonální)
	- architektura typu Load-Execute-Store – máme zvlášť instrukce na load a store, s pamětí nejde dělat nic jiného
- hardwarová architektura
	- procesor
		- řadič paměti
		- cache
		- jádra – logické procesory + registry
	- hyper-threading – na jedné výpočetní jednotce (uvnitř jádra) běží dvě instrukce najednou
		- uvnitř jednoho jádra jsou dvě vlákna (logické procesory) – může jich být i víc
		- zvyšuje to výkon, schovává to latenci přístupu do paměti
		- každé vlákno má své registry
	- hierarchie keší
		- privátní (na každém jádru)
			- L1I a L1D – malé keše
			- L2 – větší, pro kód (instrukce) i data
		- sdílená
			- L3/LLC – velká; dneska má obvykle každé jádro vlastní L3\$ slice
	- 95 % přístupů do paměti jde z nějaké úrovně cache (což je fajn, protože paměť je pomalá)
	- out-of-order execution – instrukce si procesor popřehází, aby to bylo rychlejší (ale výsledek odpovídá tomu, jako by je vykonával ve správném pořadí)
- pipeline
	- jednotlivé kroky (stage) jedné instrukce: načtení instrukce z paměti, její dekódování, vykonání, paměťová operace, zápis výsledku do registru
	- najednou se můžou vykonávat všechny kroky instrukce (takže vlákno v jednu chvíli zpracovává pět instrukcí – u každé z nich je v jiné stagi)
	- je potřeba řešit správné pořadí zápisů a načtení dat
	- problém s podmíněnými skoky – ve chvíli, kdy zjistím, že mám skákat, už bych vykonával stage u dalších instrukcí
		- používá se branch predictor, zkouší odhadnout, kam se skočí
		- když to odhadne špatně, tak se pipeline restartuje
		- hledá ve skákání nějaké vzory, zkouší hádat
		- pokud instrukci na dané adrese nikdy neviděl, tak zpětný skok předpokládá, naopak dopředný skok nikoliv
- superskalární procesor
	- jsme schopni souběžně zpracovávat více instrukcí
	- dnešní procesory jsou pěticestné – najednou zpracovávají pět instrukcí
	- dnes se používá asymetrická superskalarita – jedna pipeline je silnější a zvládá všechno, čtyři zbývající jsou slabší a zvládají jenom jednoduché instrukce
- out-of-order execution
	- mikroinstrukce se umístí do poolu a čekají, až budou mít výkonné jednotky volno
	- jednotlivé jednotky umí různé věci

## Paměť

- podle rychlosti: registry, cache, RAM, perzistentní RAM, SSD + flash disky, HDD, magnetické pásky
	- od perzistentní RAM (včetně) ta média drží data po vypnutí
	- po perzistentní RAM (včetně) jsou uložená data přístupná CPU, zbytek je obsluhován vždy nějakým řadičem (jako externí I/O)
- paměť – definice
	- každá paměť se skládá z paměťových buněk – bitů
	- bity jsou seskupeny do slov fixní délky
	- každé slovo je přístupné binární adresou (podle délky adresy rozlišujeme např. 32 nebo 64bitovou architekturu)
		- můžeme uložit $2^N$ slov, kde $N$ je délka adresy
	- dnes se používá 8bitové slovo (bajt)
- fyzický pohled na paměť
	- paměť je vlastně dvojrozměrná
	- adresa se dekóduje tak, aby paměťový řadič našel správnou řádku a sloupec v ní
	- když bajty jsou za sebou, jsou v jedné řádce
	- časování
		- CAS – Column Access Strobe, kolik taktů trvá, než jsem schopný adresovat další sloupec uvnitř jedné řádky (tento parametr ovlivňuje cenu paměti)
		- další 3 parametry
- datová reprezentace
	- celá čísla
		- bezznaménková
			- jednoduchá binární reprezentace čísla
			- obvykle 1, 2, 4, 8 bytů
			- reprezentovaný rozsah $[0;2^N-1]$
		- znaménková
			- dvojkový doplněk
			- bitová negace + 1
			- pouze jedna 0
			- kompatibilní s bezznaménkovou aritmetikou
			- asymetrický rozsah $[-2^{N-1};2^{N-1}-1]$
			- MSb určuje znaménko čísla
	- desetinná čísla – float
		- $\text{value}=(-1)^{\text{sign}}\cdot\text{significand}\cdot 2^{\text{exponent}-\text{bias}}$
		- tohle je reprezentace v paměti, procesory si to ukládají po svém
- endianita – vícebytová čísla se v paměti ukládají tak, že je MSB na začátku (big endian), nebo LSB na začátku (little endian)
- zarovnání dat
	- moderní procesory vyžadují, aby byla data v paměti zarovnaná podle jejich velikosti
	- např. 4bajtový int musí mít adresu zarovnanou na 4 (dělitelnou čtyřmi)
	- celá struktura (struct) je zarovnaná na největší datový typ dostupný na CPU (např. 16B)
	- některé jazyky přehazují položky ve struktuře, aby se eliminovalo volné místo
	- sizeof vrátí velikost včetně těch mezer 
- správa paměti
	- globální proměnné – přiřazena na začátku, celou dobu drží svoji hodnotu, je na jednom místě v paměti
	- lokální proměnné, argumenty funkcí – uloženy na zásobníku
	- dynamicky alokované proměnné – programátor je explicitně alokuje (pomocí `malloc()`, `new`, `unique_ptr`, …), existuje vyhrazený blok paměti pro tyto alokace
- alokace paměti
	- úkol – najdi blok nepoužité paměti dostatečné velikosti, alokuj část velkého poolu paměti (používá se pojem heap)
	- životní cyklus – alokuj blok, použij blok, uvolni blok
	- vždy existuje určitý počet bytů, který lze minimálně alokovat – takže na jednobytovou proměnnou se alokuje zbytečně moc paměti (proto není dobré příliš používat `new`)
- fragmentace
	- interní – v bloku je alokováno více paměti, než je potřeba
	- externí – volná paměť je rozdělena do malých bloků a mezi nimi jsou bloky alokované paměti
- dynamická alokace paměti – mám spojový seznam volných bloků nebo bitmapu (kde každý bit reprezentuje jeden blok)
- alokační algoritmy
	- first fit – začíná na začátku, najde první dostatečně velké volné místo
	- next fit – stejné jako first fit, akorát začíná na pozici, kde bylo alokováno naposledy
	- best fit – začíná na začátku, najde nejmenší dost velké volné místo
		- vytváří malinké díry
	- worst fit – začíná na začátku, najde největší místo