# C\# cvičení

- 0\. cvičení
	- pokud máme nápad na téma a nevíme, jak technologii zakomponovat – říct Kliberovi, třeba ho něco napadne (vláknování lze nacpat skoro všude)
	- osobní odevzdání Kliberovi
		- na Malé Straně nebo přes Zoom
		- lze během prázdnin nebo klidně zítra
	- dokumentace
		- komentáře v kódu u metod (co metody dělají)
		- průvodní dokument (kde metody hledat) – něco jako 2 A4
	- 10–12 úkolů, z nich mít 5 (3+2 nebo 3+1+1)
		- odevzdávání do GitLabu
		- nebudou testy, máme si napsat vlastní, odladit si aplikaci sami
		- nebude formální zadání
			- pokud nebudeme na cvičení, tak můžeme napsat mail Kliberovi, aby nám to zadal, nebo se podívat na Ježkovo cvičení
		- z 0. cvičení není úkol
		- úkoly na sebe až na výjimky nebudou navazovat
- maďarská notace (Hungarian notation)
	- místo `c` jako čísla řádku a `d` jako čísla sloupce pojmenuju proměnné `cRow`, `cCol`
		- protože bug `c = d;` se blbě hledá
		- v C# se to dneska dá řešit pomocí struktur Row a Column
			- budou to struktury s Value
			- Value může být field nebo vlastnost
			- argument pro field
				- nebudu chtít provádět nějaké speciální výpočty
			- argumenty pro vlastnost
				- lze to udělat immutable (ale to jde i s fieldy pomocí readonly struktury)
				- lze kontrolovat rozsah
			- paměťově to vychází stejně jako int
			- co rychlost?
				- sharplab.io
				- podle assembleru, který nám vygeneroval JIT, to vypadá, že jsou všechny tři varianty (int, field, auto-implemented property) velmi podobné (field a vlastnost jsou stejné, field a int jsou technicky mírně odlišné, ale prakticky jsou taky stejné)
			- pokud by hodnoty neopustily funkci, JIT je optimalizuje, jak to jen jde
	- nebo `double distMeters`
	- do názvu identifikátoru se kóduje jeho sémantika
	- Charles Petzold to viděl, ale špatně to pochopil
		- myslel si, že se do názvu identifikátoru kóduje jeho typ
		- vydal knížku
		- takže si všichni myslí, že maďarská notace je blbost, protože kóduje typ
- extension metody
	- pokud překladač nenajde vhodnou metodu, kouká do statických tříd a hledá extension metody
	- situace
		- máme dvě assemblies (knihovnu a hlavní program)
		- v programu máme extension metodu
		- po překladu hlavního programu do knihovny přidáme implementaci extension metody v původní třídě (tudíž ta by měla mít prioritu)
		- ale bude se volat extension metoda – protože do CIL kódu překladač vygeneroval volání extension metody
	- jak fungují extension metody u hodnotových typů?
		- pokud chci hodnotový typ z metody upravovat, musím parametr `this` nastavit jako tracking referenci (napsat např. `ref this Point p`)
			- od určité verze C# to funguje klasickým voláním – není potřeba manuálně získat tracking referenci na proměnnou
	- s extension metodami to moc nepřehánět
- fyzikální simulace
	- máme čas v sekundách a vzdálenost v metrech, nechceme to přiřazovat napříč, řešením jsou opět struktury
	- chceme počítat minimum z několika hodnot v metrech
		- Math.Min nám vrátí double, pomocí extension metod a fluent syntaxe to převedeme na metry
- převod mezi Fraction a double
	- dávala by smysl implicitní konverze?
	- asi radši explicitní oběma směry
	- z Fraction na double by možná šla implicitní – holt očekáváme ztrátu přesnosti
- převod mezi Fraction a int
	- int → Fraction implicitně
	- Fraction → int explicitně
- operátory, indexery, vlastnosti a události se kompilují do normálních metod
	- `op_Implicit`
	- `op_Explicit`
	- `get_*`
	- `set_*`
- můžeme definovat overloading operátorů (sčítání, odčítání apod.)
- domácí úkol
	- fyzikální knihovna
	- co má umět?
	- fyzikální knihovna pro hru bude jiná než pro jaderné výbuchy
	- v TestConsoleApp/Program.cs je nějaká demonstrace
	- JumpingPlatformGame
		- windows forms
		- nemusíme se starat o UI
		- máme vzít Entities
			- dodat funkcionalitu, aby to umělo běhat doleva, doprava
		- kód v MainForm nemodifikovat (usingy můžeme upravovat)
			- to, co svítí červeně, tam typicky něco chybí
		- funkce RegisterEntity
		- funkce Update($\Delta s$)
			- odsimulovat, že uběhlo několik sekund – o ty je potřeba entity posunout vůči minule
		- nevadí, že simulace nebude absolutně přesná (např. z hlediska hranic obrazovky)
	- přímo ve winforms jsou nadefinované barevné čtverečky jako nějaké labels
		- neočekává se, že tam bude mnoho jezdících komponent
		- takhle se hry nedělají, tohle je jen pro jednoduchost
	- naklonovat projekt z gitlabu, vyrobit takové řešení, které funguje
	- nahrát do gitlabu, zaškrtnout v sisu
	- můžeme gitlab používat, jak jsme zvyklí
	- čas je do příštího cvičení
	- simulace už tam je naprogramovaná, jen tam chybí ta fyzikální knihovna
		- pohyb do stran, u některých postaviček skákání
		- pohyb i skákání je lineární, nesnažit se to přepsat
- interfaces
	- IIntValue – vyžaduje intovou vlastnost Value
	- IIncrementable – vyžaduje voidovou metodu Increment
- jak docílit, aby parametr implementoval oba interfacy?
	- jeden interface může dědit od druhého
	- nebo použiju generickou metodu
- pokud generickou metodu zavolám s hodnotovým parametrem, tak se neboxuje
	- to je kontrast vůči metodě s interfacovým parametrem – pokud je parametr struktura, tak se boxuje
- přetěžování metod nám pomůže, když chceme metodu volat s parametry různých typů (nebo interfaců)
	- když má metoda `f` dvě varianty pro parametr `IA` a `IB`, tak se náš kód nepřeloží, pokud nějaký typ implementuje oba interfacy
	- musíme přetypováním rozhodnout, kterou variantu chceme zvolit
- dají se takhle přetěžovat generické metody?
	- pokud bychom nechtěli boxovat struktury
	- `f<T>(T t) where T : IA`
	- `f<T>(T t) where T : IB`
	- v CIL kódu není informace o constraints, je to jenom v metadatech
	- takže tohle se nepřeloží :(
	- jak to ohackovat?
		- dáme metody do různých typů – jeden dědí od druhého (takže nový přidáme *nad* ten stávající)
		- ale takhle zakryjeme jednu z metod
		- takže to taky nefunguje
	- použijeme extension metodu!
		- ale to nefunguje úplně dokonale
		- pokud bychom chtěli další metodu, museli bychom vytvořit další třídu
		- problém máme taky s viditelností – nevidíme private věci
	- žádné lepší řešení zatím neznáme
- domácí úkol
	- nové zadání si stáhneme pomocí tlačítka Update Fork v GitLabu
	- chceme udělat něco lepšího než winforms ;)
	- Control je obecný prvek okénkového systému
	- chtěli bychom přidat Panel, který obsahuje několik Controls
	- Panel může obsahovat i Panel
	- úkol: přidat podporu pro dva druhy panelů
		- StackPanel obsahuje seznam (nebo prostě nějakou datovou strukturu) komponent, které jsou v něm
		- Canvas obsahuje kromě komponent i informace o jejich souřadnicích
	- chtěli bychom tyhle Controls vyrábět a používat pomocí fluent syntax
		- metody vracejí this – dají se hezky řetězit
		- `var image = new Image().WithUrl(…).WithZoom(…);`
		- with by v nás mohlo evokovat imutabilitu – ale tady to neplatí, vracíme přímo objekt samotný, ne jeho kopie
	- měli bychom dodržet formát výstupu – viz reference-output
	- chtěli bychom přidat fluent syntax podporu i pro panely
		- PlacedIn
		- mělo by být jedno, jestli se to tam nejdřív umístí a pak nastaví URL nebo naopak
		- u Canvasu se hned za PlacedIn musí volat At
			- pokud se místo At volá něco jiného, nemá to jít přeložit
			- pokud se pak už nic nevolá, tak to může jít přeložit, ale nemělo by se nic stát
	- nemusíme řešit překrývání apod.
	- deadline – do příštího týdne (společně s předchozím úkolem)

---

- domácí úkol na fyziku
	- jak pojmenovat typy?
	- asi lepší Meters než Distance, protože to stejně budeme ukládat v metrech
	- v dotnetu je typ TimeSpan
		- ale my v naší hře nepotřebujeme být tak obecní
	- mohlo by být vhodnější mít jednotky Pixel, Frame a PixelsPerFrame?
	- z hlediska času (i prostoru )je struktura zadarmo – počítání je stejně rychlé jako počítání přímo s doubly
	- jak napsat extension metody jednodušeji?
		- můžeme použít generické metody s omezením, aby to byl `IConvertible` a `INumber<T>`
		- pak máme trochu problém s charem, protože `'5'.Meters()` je vlastně 53 metrů
		- podobný problém může nastat u typu decimal, když tam uložíme 0.1
		- takže je asi lepší podporovat jenom int a double, protože to bylo v zadání
	- nejde nějak rozumně zobecnit operátory
		- ale to nevadí, tady duplikace kódu není problém – je ho málo a nebude se měnit
- domácí úkol s panely
	- kód uvnitř Canvasu a StackPanelu je hodně podobný
	- můžeme udělat abstraktní Panel
	- v Canvasu přidáme seznam souřadnic – seznam Controls je protected, takže můžeme předpokládat, že nikdo nebude měnit pořadí
	- název typu, který potřebujeme k ToString, můžeme uložit do abstraktní statické vlastnosti
		- asi radši ne public, protože pak by to lidi začali používat a my bychom to nemohli změnit
	- jak se zbavit overheadu?
		- pomocí generických typů
		- ale ty to zesložití
- domácí úkol
	- immutabilita je fajn
	- místo změny vytořím kopii se změnou
		- With
	- programujeme SIS
	- Person
		- Teacher
			- CoursesHeld
		- Student
			- DateEnrolled
	- všechno to má být immutable
	- pokud je to immutable, dost často potřebuju vytvářet instance
	- vlastně bych mohl mít nějakého defaultního studenta s výchozími hodnotami, je zbytečné ho alokovat pořád znova a znova
	- položky se mění po jedné – nedají se změnit dvě naráz
	- u recordů funguje klíčové slovo With – to ale nyní nebudeme používat ani bychom ho neměli analyzovat (může nás posunout špatným směrem)
	- dává smysl, aby to byly třídy (ne struktury)
	- pro jednoduchost je nám jedno, jaký typ vrací `justStudents.WithPasswordResetByFirstName`
		- ideální by bylo, kdyby to vracelo `List<Student>`
		- když nám to nepůjde, tak nevadí
	- typy udělat co nejvíc immutable to půjde
		- u vlastností dát init, private set nebo protected set (nejlepší je init)
- užitečné constraints pro generické typy
	- struct – hodnotový typ (kromě Nullable)
	- class – referenční typ
	- new() – má bezparametrický konstruktor
- řešení úkolu s immutable studenty
	- máme abstraktní Person
	- z něj vychází role Student, Teacher
		- rolí může být víc
	- vlastností Person i vlastností jednotlivých rolí může být víc
	- můžou být i nějací potomci Studenta apod.
	- co bude vracet WithName zavolaná na Studentovi?
		- musí vracet Studenta
	- při použití se nejdříve nastavují obecné hodnoty, až pak ta specifická
		- připomíná to builder pattern
			- budeme mít mutable builder, kterému postupně nastavujeme hodnoty → nakonec vytvoříme instanci Person
		- může být užitečné použít klíčové slovo required – uvnitř builderu máme k dispozici ale i silnější nástroje (třeba kontrolu toho, že nejsou zároveň nastaveny FirstName, LastName a FullName)
		- ale builder pattern neřeší náš problém s vracením specifického typu
			- PersonBuilder musí být generický
			- `PersonBuilder<TSelf> where TSelf : PersonBuilder<TSelf>`
				- taky se používá TConcreteSelf, TSpecific, apod.
			- uvnitř WithName musíme this explicitně přetypovat na TSelf – ale my víme, že PersonBuilder je abstraktní, takže to nevadí (pokud někdo nevytvoří divného potomka PersonBuilderu)
		- vyřešili jsme vracení specifického typu, ale builder neřeší náš problém
	- použijeme `Person<TSelf>`
		- musíme zajistit kopírování
		- takže použijeme constraint na `new()`
		- jak okopírovat data?
			- nejsem schopen požadovat specifický konstruktor
			- takže budu mít virtuální/abstraktní metodu Copy
			- ta bude brát jako parametry name a password
				- šlo by to i líp, ale zbavili bychom se extrémní immutability
		- do `Person<TSelf>` můžu dát statickou vlastnost Default (s výchozí hodnotou rovnou instanci TSelf)
	- musíme vytvořit ještě rodiče Person, od kterého bude dědit `Person<TSelf>`
		- Person musí mít WithName a WithPassword
		- můžeme to zajistit zakrýváním metod nebo pomocí virtuálních metod
	- `List<Student>` a `List<Person>` jsou invariantní
		- metoda PrintAll může být generická
		- nebo může mít parametr `IReadonlyList<Person>`, který je kovariantní
			- případně něco slabšího – klidně `IEnumerable<Person>`
- další domácí úkol
	- zadání úkolu na videu
	- vyrábíme knihovnu na práci s desetinnými čísly ve fixed point aritmetice
	- specifikuju pozici desetinné čárky
		- Q3.5 … 3 bity před desetinnou čárkou, 5 bitů za ní
	- používáme celočíselné operace procesoru (`+ - * /`)
	- chceme tam mít metodu ToDouble a taky hezkou metodu ToString, aby se to správně vypisovalo
	- konstruktory
		- pro double
		- pro celé číslo
	- generický typ Fixed
		- definujeme typ, kterým budeme čísla interně reprezentovat (byte, short, int, long)
		- definujeme počet bitů za desetinnou čárkou
			- zavedeme typy Dot3, Dot4, Dot8, Dot16, Dot24
			- nemusíme kontrolovat, že je za desetinnou čárkou nejvýš tolik bitů, kolik typ podporuje
	- nebudeme kontrolovat přetečení – vždycky provedeme truncation
	- chceme metodu To, která zajistí převod na jinou fixed-point reprezentaci
	- aby se na Listu vhodných typů (třeba i intů) dalo provést SumAll
		- můžou se nám hodit interfacy
			- viz interfacy pod IBinaryInteger (a INumberBase)
		- https://learn.microsoft.com/en-us/dotnet/standard/generics/math
		- můžou se nám hodit identity (AdditiveIdentity, MultiplicativeIdentity)
		- můžou se nám hodit factory metody Create uvnitř INumberBase
	- záporná čísla nemusíme řešit

---

- domácí úkol: u DotX typů bylo vhodné použít abstraktní statickou vlastnost (to od C# 11 umožňují interfacy, viz poznámky z přednášky)
- když chci vypsat položky pozpátku, tak raději použiju IReadOnlyList, protože při použití IEnumerable by to spotřebovalo O(n) paměti
- pozor, kovariance funguje jenom pro referenční typy
	- takže když máme metodu s parametrem typu `IEnumerable<object>`, tak jí nemůžeme předat seznam intů
	- řešením by byla generická metoda, ale pak by se pro každý odlišný list JITovala další metoda
		- ale to obvykle není problém
		- pro všechny referenční typy se JITuje jen jedna společná varianta, pro každý hodnotový typ se JITuje samostatná
- mohl by být IReadOnlyDictonary deklarován takto? `IReadOnlyDictionary<in TKey, out TValue>`
	- teoreticky mohl – indexer má `TKey` jako parametr, takže tam musí být `in` nebo nic
		- naopak vrací `TValue`, takže tam musí být `out` nebo nic
	- ale obsahuje `IEnumerable<TKey> Keys`, takže TKey musí být `out` nebo nic
	- zároveň typ implementuje interface `IEnumerable<KeyValuePair<TKey, TValue>>`
		- bylo by neefektivní KeyValuePair alokovat – takže je to struktura, což je hodnotový typ, takže tam žádná variance nefunguje
	- takže je IReadOnlyDictonary deklarován jako `IReadOnlyDictionary<TKey, TValue>`
- domácí úkol
	- imlementujeme validační framework
	- klient posílá požadavky na server
	- hlídáme, aby klient serveru neposílal blbosti
	- náš přístup
		- přijdou nám data k objednávce
		- nejdřív zavoláme `new Order()`
		- až pak `Order` validujeme pomocí metody `Validate`
		- dalo by se to dělat i naopak, ale tento přístup je jednodušší
	- validace může mít potenciálně více problémů
		- výstupem validace je seznam validačních chyb … `List<ValidationError>`
		- seznam bude prázdný, když tam není žádný problém
	- validátory
		- NonBlankStringValidator
		- rangeValidator
		- StringLengthValidator
		- NotNullValidator
			- pozor, textová reprezentace nullu v C# je `""`
	- ze základních validátorů skládáme uživatelský validátor
		- OrderValidator
			- jeho rozhraním je metoda Validate – je na nás, jak bude vypadat její hlavička
			- postupně budu validovat části Orderu
			- výsledkem validace je jeden List obsahující všechny validační chyby
				- použijeme metodu AddRange, která je na Listu
			- (asi uvnitř OrderValidatoru?) budeme potřebovat nějakou variantu metody ValidateAll, přičemž té metodě budeme moct předat více validátorů
				- použijeme [klíčové slovo `params`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/method-parameters#params-modifier)
			- bylo by fajn, kdybych mohl SuperOrdery zvalidovat klasickým OrderValidatorem
				- v metodě ValidateSuperOrder
	- úkol má rozšíření, za které dostaneme bonusové body
		- AdvancedOrderValidator
		- vymyslet podobnou, ale kompaktnější syntaxi
			- můžou tam být jiné závorky apod.
			- chci se zbavit `new` a typových parametrů (pokud se dají odvodit)
- řešení domácího úkolu
	- můžeme vrazit nad Validator (nebo místo něj?) interface IValidator s kontravariancí
	- nemusíme nutit všechny Validatory, aby vracely List
		- stačil by IList, ICollection, IReadOnlyCollection nebo IEnumerable
	- když je chyba právě jedna, tak může být efektivní vrátit pole délky 1
		- nebo nějaký jednoduchý enumerable
	- pro prázdný seznam chyb
		- můžu použít `Array<ValidationError>.Empty`
	- na validaci délky stringu nepotřebuju range validator – stačí validátor intů
	- na validaci range je lepší IComparable, protože IComparisonOperators je mladší interface (navíc se někdy nedá použít)
	- je fajn metody optimalizovat tak, aby s nula chybami byly co nejefektivnější
	- je vhodné nějaký typ ComplexValidatorBase, který bude sloužit jako základ pro implementaci složitějších validátorů
		- abych metodu Validate nemusel mít samostatně ve všech takových validátorech
	- metoda Validate v ComplexValidatorBase
		- typické použití metody Validate – s jedním validátorem, zbytečně to alokuje pole
		- podporuje to situaci, kdy tam nedám nic
		- možná by dávalo smysl první validátor psát explicitně (jako druhý parametr, params dát až jako třetí parametr)
	- advanced validator
		- hlavní problém s RangeValidatorem
		- typová inference funguje v metodách, ne v typech
			- C# překladač neumí dedukovat typové argumenty z volání konstruktoru
		- když máme problém s konstruktorem → použijeme factory metodu
		- ale ta factory metoda nemůže být v generickém typu, protože by byla negenerická
		- my potřebujeme generickou factory metodu v negenerickém typu
		- vyřešili jsme to, ale my chceme, aby se podle typu validované věci odvodil typ validátoru
			- to jde fluent syntaxí
			- `Amount.IsInRange(1,10).Validate()`
	- u Listu se dá nastavit počáteční alokovaná délka (ne že bychom to měli používat – objevilo se to ve studentském řešení)
- domácí úkol – zadání je v GitLabu
	- velikost jednoho bloku – nějaká mocnina dvojky (asi 32 nebo 64)
	- implementujeme `IList<T>`
	- pustit si testy, máme tam popsané, co vlastně dělají
	- do varianty B můžeme zkopírovat zdroják (lišit se bude enumerátor)
		- asi je jednodušší začít variantou B
		- za každou část je jedno OK
	- vyrobit `IDeque<T>`
	- součástí úkolů je reverzní pohled na Deque
		- metoda GetReverseView, která přijímá Deque a vrací ReverseView
		- přidání prvku na konec reverseview odpovídání přidání na začátek původní fronty
		- je to opravdu jenom pohled, takže jsem schopný data modifikovat oběma objekty
		- můžu vyrobit reverse reverse view
		- reverse view obsahuje referenci na původní deque
			- volání metod se převádí na volání metod na původním deque (s nějakými indexovými výpočty)
			- vyrobení ReverseView má být O(1)
		- když zavolám GetReverseView na ReverseView, tak to má vrátit ReverseView ukazující na ReverseView (ne původní deque)
	- zamyslet se nad použitými datovými strukturami u Map a Block
		- list listů, pole polí, pole listů, list polí?
	- deadline za dva týdny
	- příští cvičení nebude
	- můžeme přijít na sedmé cvičení příští rok
- odstraňujeme sudé položky seznamu
	- tři možnosti
		- pomocí Remove … $O(n^2)$
		- pomocí RemoveAt … $O(n^2)$, ale rychlejší než Remove
		- pomocí RemoveAll … $O(n)$
	- RemoveAll
		- bere delegáta
		- je schopný teoreticky pracovat nějak efektivněji – může mít seznam v nějakém rozbitém stavu, který nakonec opraví
		- ale je s ním spojený nějaký overhead
		- trikově jsme schopni implementovat odstraňování položek seznamu v $O(n)$ i bez RemoveAll, které bude o konstantu efektivnější než RemoveAll
		- pokud odstraňujeme jen jednu položku, tak je RemoveAll poměrně neefektivní
- jak funguje internet
	- klient si povídá se serverem
		- TCP/IP spojení
		- třeba u webu to spojení běží na portu 80
		- textový protokol HTTP
		- nejčastější požadavek GET s jedním parametrem (cesta k souboru)
		- dříve server prostě vrátil požadovaný soubor, který našel na disku
		- dnes je tam často nějaká vrstva (PHP nebo třeba C#), která nějak vytvoří odpověď
	- distribuované aplikace
		- aplikace a knihovna
		- aplikace běží u klienta, knihovna by mohla být na serveru
		- RPC (remote procedure call)
		- chci volat statickou metodu `m`, k tomu se zneužije HTTP protokol
			- místo cesty k souboru se do dotazu zakóduje metoda
			- parametry jsem schopný předat pomocí query
		- knihovna běží jako webová služba (web service)
			- k tomu se často používá REST (součástí je webové API)
			- někdy je k dispozici dokumentace API
			- https://b2c.cpost.cz/?urls.primaryName=B2C%20PostCode%20API
- jak získat data z webového API v C#
	- chtěli bychom volat nějakou metodu GetString na třídě HttpClient, která vrátí data, které přijdou ze serveru
	- ale takové metoda neexistuje, je tam metoda GetStringAsync, která vrátí `Task<string>`
		- my na Tasku použijeme vlastnost Result, ta nám vrátí ten string, který chceme
		- tohle je špatný způsob, jak to programovat, ale zatím to budeme dělat takhle, protože nic lepšího neumíme (asynchronní programování budeme dělat až na konci)
	- můžu deserializovat kolekci (třeba IReadOnlyList)
		- můžu použít JsonSerializerOptions nastavení pro Web (názvy vlastností jsou case-insensitive)
		- nebo můžu odekorovat vlastnosti tím, jak se jmenují v tom JSONu
	- NuGet balíček Refit
		- umožní mi v C# silně typovaně popsat webovou službu
		- jenom napíšu interface, Refit dodá jeho implementaci
- domácí úkol
	- 1. část
		- Coinbase API
			- https://api.coinbase.com/v2/currencies
			- https://api.coinbase.com/v2/exchange-rates?currency=EUR
			- https://api.coinbase.com/v2/exchange-rates?currency=CZK
		- za úkol máme pomocí Refitu připravit implementaci API
	- 2. část
		- kdyby svět byl krásný, tak by kromě třídy HttpClient existoval i HttpListener, ale ten je obsolete
		- v ASP.NET existuje webový server Kestrel
		- vyrobíme konzolovou aplikaci, protože ASP templaty jsou moc pokročilé
		- Kestrel v základní sadě dostupných knihoven chybí
			- chceme přidat referenci do záložky Frameworks ve Visual Studiu
			- to uděláme tak, že v csproj souboru upravíme `<Project Sdk="Microsoft.NET.Sdk">` na `<Project Sdk="Microsoft.NET.Sdk.Web">`
		- webový server se vyrábí pomocí builder patternu
			- konfiguruje se metodou Run, což je blbost, ale tak to je
			- interně je to implementované vícevláknově
		- my budeme implementovat třídu RequestProcessor
			- pro jednoduchost budeme vracet HTTP 200 OK
		- prohlížeč občas automaticky hází requesty na favicon.ico, ty můžeme ignorovat (třeba vracet prázdný JSON)
		- chtěli bychom napsat framework, který vezme implementaci GetPostCodesByCityAndStreet a zpřístupní ho na nějaké konkrétní adrese (/services/PostCode/getDataAsJson)
		- HandleRequest
			- RouteMap vrátí delegáta
			- z requestu vytaháme parametry, musíme reflexí zkontrolovat, jestli odpovídají delegátovi
		- implementujeme obecný framework
			- v RegisterAllRoutes musíme najít všechny typy v dané assembly, které implementují ten interface ISimplisticRoutesHandler, instaciovat je bezparametrickým konstruktorem (pomocí Activator.CreateInstance) a na instancích zavolat RegisterRoutes
	- 3. část
		- fejková implementace Coinbase API
		- stačí pár měn, data si můžeme vycucat z prstu
		- mělo by to být type-safe (exchange rates aby byly decimal)
	- ultimátní zkontrolování, že nám to funguje – zkusit pomocí části 1 použít části 2 a 3
		- nejspíš je potřeba použít HTTP variantu adresy (ne HTTPS)
	- pozor
		- nejsme schopni mít generického delegáta v metodě Map
		- potřebujeme typ System.Delegate
		- je tam metoda DynamicInvoke, která bere `params object[]`
			- to je ekvivalentní volání Invoke na MethodInfo
- deque
	- problémy se jmény – enqueue, dequeue? asi raději Add a Remove nebo Pop a Push vždycky s Front/Back
	- v interfacu může být i metoda Peek – nic nás nestojí
	- IDeque může implementovat ICollection, IDequeList bude implementovat IList
	- metodu Add (bez přívlastku) schovám – udělám ji jako implementaci interfacové metody
		- podobně můžu schovat IsReadOnly
	- enumerátor by měl poznat concurrent modification a vyhodit výjimku
		- i pokud někdo zavolá Clear – v takovém případě MoveNext vrátí false a nečte se Current, takže je potřeba to nějak vyřešit (třeba zapamatováním Countu)
	- většina metod se dá delegovat na enumerátor, ten se dá delegovat na indexer
	- jak otestovat delegované metody bez implementace indexeru? napíšu si triviální (špatnou) implementaci deque – pomocí Listu
	- jak zajistit, aby ReverseView viděl \_version? třeba tak, že to bude vnořený typ uvnitř Deque
	- třeba u shiftování možná nedává smysl furt dokola počítat indexy – ale vyplatí se to dělat efektivněji? asi bychom to museli zbenchmarkovat
- web api
	- interface můžu vytáhnout pomocí GetInterface
		- kdyby to implementovala nějaká abstraktní třída, tak by to asi padalo
- LINQ
	- `from x in alpha where x < 5 orderby x select x*2`
		- linqový dotaz
		- překladač z toho slepě udělá `alpha.Where(x => x < 5).OrderBy(x => x).Select(x => x*2)`
	- sémantiku tomu dodává nějaká knihovna – např. LinqToObjects
		- tahle knihovna je postavená na IEnumerable
		- ne všechny metody mají „hezkou“ dotazovou variantu – třeba ToList nebo ToArray
			- můžu vzít dotaz, dát ho do závorek a za něj napsat např. ToList, pak to funguje
		- je na nás, jestli budeme domácí úkol řešit pomocí dotazové nebo metodové varianty, ale z cvičných důvodů je lepší zkusit tu dotazovou
		- Select vrací nějaký typ, který implementuje IEnumerable
	- pozor, informace o LINQu, které najdeme na internetu, jsou často pochybné
	- když data potřebuju jednou projít a zahodit, tak je k ničemu volat ToList
- úkol
	- máme lidi, ti mají přátele
	- jsou tam nějaké věci kvůli ladění, ty nemáme používat (viz komentáře v kódu)
	- pozor, relace přátelství není symetrická
	- napíšeme dotazy podle zadání
	- připravíme si metodu (třeba PrintAll), která vyenumeruje dotaz a vypíše lidi
	- v 6B bude dávat smysl použít dotaz z 6 jako základ
	- je tam exe, které můžeme pustit – v takovém pořadí máme lidi vypisovat
