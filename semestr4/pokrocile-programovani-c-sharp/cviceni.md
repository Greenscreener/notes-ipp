# C\# cvičení

- 0\. cvičení
	- pokud máme nápad na téma a nevíme, jak technologii zakomponovat – říct Kliberovi, třeba ho něco napadne (vláknování lze nacpat skoro všude)
	- osobní odevzdání Kliberovi
		- na Malé Straně nebo přes Zoom
		- lze během prázdnin nebo klidně zítra
	- dokumentace
		- komentáře v kódu u metod (co metody dělají)
		- průvodní dokument (kde metody hledat) – něco jako 2 A4
	- 10–12 úkolů, z nich mít 5 (3+2 nebo 3+1+1)
		- odevzdávání do GitLabu
		- nebudou testy, máme si napsat vlastní, odladit si aplikaci sami
		- nebude formální zadání
			- pokud nebudeme na cvičení, tak můžeme napsat mail Kliberovi, aby nám to zadal, nebo se podívat na Ježkovo cvičení
		- z 0. cvičení není úkol
		- úkoly na sebe až na výjimky nebudou navazovat
- maďarská notace (Hungarian notation)
	- místo `c` jako čísla řádku a `d` jako čísla sloupce pojmenuju proměnné `cRow`, `cCol`
		- protože bug `c = d;` se blbě hledá
		- v C# se to dneska dá řešit pomocí struktur Row a Column
			- budou to struktury s Value
			- Value může být field nebo vlastnost
			- argument pro field
				- nebudu chtít provádět nějaké speciální výpočty
			- argumenty pro vlastnost
				- lze to udělat immutable (ale to jde i s fieldy pomocí readonly struktury)
				- lze kontrolovat rozsah
			- paměťově to vychází stejně jako int
			- co rychlost?
				- sharplab.io
				- podle assembleru, který nám vygeneroval JIT, to vypadá, že jsou všechny tři varianty (int, field, auto-implemented property) velmi podobné (field a vlastnost jsou stejné, field a int jsou technicky mírně odlišné, ale prakticky jsou taky stejné)
			- pokud by hodnoty neopustily funkci, JIT je optimalizuje, jak to jen jde
	- nebo `double distMeters`
	- do názvu identifikátoru se kóduje jeho sémantika
	- Charles Petzold to viděl, ale špatně to pochopil
		- myslel si, že se do názvu identifikátoru kóduje jeho typ
		- vydal knížku
		- takže si všichni myslí, že maďarská notace je blbost, protože kóduje typ
- extension metody
	- pokud překladač nenajde vhodnou metodu, kouká do statických tříd a hledá extension metody
	- situace
		- máme dvě assemblies (knihovnu a hlavní program)
		- v programu máme extension metodu
		- po překladu hlavního programu do knihovny přidáme implementaci extension metody v původní třídě (tudíž ta by měla mít prioritu)
		- ale bude se volat extension metoda – protože do CIL kódu překladač vygeneroval volání extension metody
	- jak fungují extension metody u hodnotových typů?
		- pokud chci hodnotový typ z metody upravovat, musím parametr `this` nastavit jako tracking referenci (napsat např. `ref this Point p`)
			- od určité verze C# to funguje klasickým voláním – není potřeba manuálně získat tracking referenci na proměnnou
	- s extension metodami to moc nepřehánět
- fyzikální simulace
	- máme čas v sekundách a vzdálenost v metrech, nechceme to přiřazovat napříč, řešením jsou opět struktury
	- chceme počítat minimum z několika hodnot v metrech
		- Math.Min nám vrátí double, pomocí extension metod a fluent syntaxe to převedeme na metry
- převod mezi Fraction a double
	- dávala by smysl implicitní konverze?
	- asi radši explicitní oběma směry
	- z Fraction na double by možná šla implicitní – holt očekáváme ztrátu přesnosti
- převod mezi Fraction a int
	- int → Fraction implicitně
	- Fraction → int explicitně
- operátory, indexery, vlastnosti a události se kompilují do normálních metod
	- `op_Implicit`
	- `op_Explicit`
	- `get_*`
	- `set_*`
- můžeme definovat overloading operátorů (sčítání, odčítání apod.)
- domácí úkol
	- fyzikální knihovna
	- co má umět?
	- fyzikální knihovna pro hru bude jiná než pro jaderné výbuchy
	- v TestConsoleApp/Program.cs je nějaká demonstrace
	- JumpingPlatformGame
		- windows forms
		- nemusíme se starat o UI
		- máme vzít Entities
			- dodat funkcionalitu, aby to umělo běhat doleva, doprava
		- kód v MainForm nemodifikovat (usingy můžeme upravovat)
			- to, co svítí červeně, tam typicky něco chybí
		- funkce RegisterEntity
		- funkce Update($\Delta s$)
			- odsimulovat, že uběhlo několik sekund – o ty je potřeba entity posunout vůči minule
		- nevadí, že simulace nebude absolutně přesná (např. z hlediska hranic obrazovky)
	- přímo ve winforms jsou nadefinované barevné čtverečky jako nějaké labels
		- neočekává se, že tam bude mnoho jezdících komponent
		- takhle se hry nedělají, tohle je jen pro jednoduchost
	- naklonovat projekt z gitlabu, vyrobit takové řešení, které funguje
	- nahrát do gitlabu, zaškrtnout v sisu
	- můžeme gitlab používat, jak jsme zvyklí
	- čas je do příštího cvičení
	- simulace už tam je naprogramovaná, jen tam chybí ta fyzikální knihovna
		- pohyb do stran, u některých postaviček skákání
		- pohyb i skákání je lineární, nesnažit se to přepsat
- interfaces
	- IIntValue – vyžaduje intovou vlastnost Value
	- IIncrementable – vyžaduje voidovou metodu Increment
- jak docílit, aby parametr implementoval oba interfacy?
	- jeden interface může dědit od druhého
	- nebo použiju generickou metodu
- pokud generickou metodu zavolám s hodnotovým parametrem, tak se neboxuje
	- to je kontrast vůči metodě s interfacovým parametrem – pokud je parametr struktura, tak se boxuje
- přetěžování metod nám pomůže, když chceme metodu volat s parametry různých typů (nebo interfaců)
	- když má metoda `f` dvě varianty pro parametr `IA` a `IB`, tak se náš kód nepřeloží, pokud nějaký typ implementuje oba interfacy
	- musíme přetypováním rozhodnout, kterou variantu chceme zvolit
- dají se takhle přetěžovat generické metody?
	- pokud bychom nechtěli boxovat struktury
	- `f<T>(T t) where T : IA`
	- `f<T>(T t) where T : IB`
	- v CIL kódu není informace o constraints, je to jenom v metadatech
	- takže tohle se nepřeloží :(
	- jak to ohackovat?
		- dáme metody do různých typů – jeden dědí od druhého (takže nový přidáme *nad* ten stávající)
		- ale takhle zakryjeme jednu z metod
		- takže to taky nefunguje
	- použijeme extension metodu!
		- ale to nefunguje úplně dokonale
		- pokud bychom chtěli další metodu, museli bychom vytvořit další třídu
		- problém máme taky s viditelností – nevidíme private věci
	- žádné lepší řešení zatím neznáme
- domácí úkol
	- nové zadání si stáhneme pomocí tlačítka Update Fork v GitLabu
	- chceme udělat něco lepšího než winforms ;)
	- Control je obecný prvek okénkového systému
	- chtěli bychom přidat Panel, který obsahuje několik Controls
	- Panel může obsahovat i Panel
	- úkol: přidat podporu pro dva druhy panelů
		- StackPanel obsahuje seznam (nebo prostě nějakou datovou strukturu) komponent, které jsou v něm
		- Canvas obsahuje kromě komponent i informace o jejich souřadnicích
	- chtěli bychom tyhle Controls vyrábět a používat pomocí fluent syntax
		- metody vracejí this – dají se hezky řetězit
		- `var image = new Image().WithUrl(…).WithZoom(…);`
		- with by v nás mohlo evokovat imutabilitu – ale tady to neplatí, vracíme přímo objekt samotný, ne jeho kopie
	- měli bychom dodržet formát výstupu – viz reference-output
	- chtěli bychom přidat fluent syntax podporu i pro panely
		- PlacedIn
		- mělo by být jedno, jestli se to tam nejdřív umístí a pak nastaví URL nebo naopak
		- u Canvasu se hned za PlacedIn musí volat At
			- pokud se místo At volá něco jiného, nemá to jít přeložit
			- pokud se pak už nic nevolá, tak to může jít přeložit, ale nemělo by se nic stát
	- nemusíme řešit překrývání apod.
	- deadline – do příštího týdne (společně s předchozím úkolem)

---

- domácí úkol na fyziku
	- jak pojmenovat typy?
	- asi lepší Meters než Distance, protože to stejně budeme ukládat v metrech
	- v dotnetu je typ TimeSpan
		- ale my v naší hře nepotřebujeme být tak obecní
	- mohlo by být vhodnější mít jednotky Pixel, Frame a PixelsPerFrame?
	- z hlediska času (i prostoru )je struktura zadarmo – počítání je stejně rychlé jako počítání přímo s doubly
	- jak napsat extension metody jednodušeji?
		- můžeme použít generické metody s omezením, aby to byl `IConvertible` a `INumber<T>`
		- pak máme trochu problém s charem, protože `'5'.Meters()` je vlastně 53 metrů
		- podobný problém může nastat u typu decimal, když tam uložíme 0.1
		- takže je asi lepší podporovat jenom int a double, protože to bylo v zadání
	- nejde nějak rozumně zobecnit operátory
		- ale to nevadí, tady duplikace kódu není problém – je ho málo a nebude se měnit
- domácí úkol s panely
	- kód uvnitř Canvasu a StackPanelu je hodně podobný
	- můžeme udělat abstraktní Panel
	- v Canvasu přidáme seznam souřadnic – seznam Controls je protected, takže můžeme předpokládat, že nikdo nebude měnit pořadí
	- název typu, který potřebujeme k ToString, můžeme uložit do abstraktní statické vlastnosti
		- asi radši ne public, protože pak by to lidi začali používat a my bychom to nemohli změnit
	- jak se zbavit overheadu?
		- pomocí generických typů
		- ale ty to zesložití
- domácí úkol
	- immutabilita je fajn
	- místo změny vytořím kopii se změnou
		- With
	- programujeme SIS
	- Person
		- Teacher
			- CoursesHeld
		- Student
			- DateEnrolled
	- všechno to má být immutable
	- pokud je to immutable, dost často potřebuju vytvářet instance
	- vlastně bych mohl mít nějakého defaultního studenta s výchozími hodnotami, je zbytečné ho alokovat pořád znova a znova
	- položky se mění po jedné – nedají se změnit dvě naráz
	- u recordů funguje klíčové slovo With – to ale nyní nebudeme používat ani bychom ho neměli analyzovat (může nás posunout špatným směrem)
	- dává smysl, aby to byly třídy (ne struktury)
	- pro jednoduchost je nám jedno, jaký typ vrací `justStudents.WithPasswordResetByFirstName`
		- ideální by bylo, kdyby to vracelo `List<Student>`
		- když nám to nepůjde, tak nevadí
	- typy udělat co nejvíc immutable to půjde
		- u vlastností dát init, private set nebo protected set (nejlepší je init)
- užitečné constraints pro generické typy
	- struct – hodnotový typ (kromě Nullable)
	- class – referenční typ
	- new() – má bezparametrický konstruktor
