# C\# cvičení

- 0\. cvičení
	- pokud máme nápad na téma a nevíme, jak technologii zakomponovat – říct Kliberovi, třeba ho něco napadne (vláknování lze nacpat skoro všude)
	- osobní odevzdání Kliberovi
		- na Malé Straně nebo přes Zoom
		- lze během prázdnin nebo klidně zítra
	- dokumentace
		- komentáře v kódu u metod (co metody dělají)
		- průvodní dokument (kde metody hledat) – něco jako 2 A4
	- 10–12 úkolů, z nich mít 5 (3+2 nebo 3+1+1)
		- odevzdávání do GitLabu
		- nebudou testy, máme si napsat vlastní, odladit si aplikaci sami
		- nebude formální zadání
			- pokud nebudeme na cvičení, tak můžeme napsat mail Kliberovi, aby nám to zadal, nebo se podívat na Ježkovo cvičení
		- z 0. cvičení není úkol
		- úkoly na sebe až na výjimky nebudou navazovat
- maďarská notace (Hungarian notation)
	- místo `c` jako čísla řádku a `d` jako čísla sloupce pojmenuju proměnné `cRow`, `cCol`
		- protože bug `c = d;` se blbě hledá
		- v C# se to dneska dá řešit pomocí struktur Row a Column
			- budou to struktury s Value
			- Value může být field nebo vlastnost
			- argument pro field
				- nebudu chtít provádět nějaké speciální výpočty
			- argumenty pro vlastnost
				- lze to udělat immutable (ale to jde i s fieldy pomocí readonly struktury)
				- lze kontrolovat rozsah
			- paměťově to vychází stejně jako int
			- co rychlost?
				- sharplab.io
				- podle assembleru, který nám vygeneroval JIT, to vypadá, že jsou všechny tři varianty (int, field, auto-implemented property) velmi podobné (field a vlastnost jsou stejné, field a int jsou technicky mírně odlišné, ale prakticky jsou taky stejné)
			- pokud by hodnoty neopustily funkci, JIT je optimalizuje, jak to jen jde
	- nebo `double distMeters`
	- do názvu identifikátoru se kóduje jeho sémantika
	- Charles Petzold to viděl, ale špatně to pochopil
		- myslel si, že se do názvu identifikátoru kóduje jeho typ
		- vydal knížku
		- takže si všichni myslí, že maďarská notace je blbost, protože kóduje typ
- extension metody
	- pokud překladač nenajde vhodnou metodu, kouká do statických tříd a hledá extension metody
	- situace
		- máme dvě assemblies (knihovnu a hlavní program)
		- v programu máme extension metodu
		- po překladu hlavního programu do knihovny přidáme implementaci extension metody v původní třídě (tudíž ta by měla mít prioritu)
		- ale bude se volat extension metoda – protože do CIL kódu překladač vygeneroval volání extension metody
	- jak fungují extension metody u hodnotových typů?
		- pokud chci hodnotový typ z metody upravovat, musím parametr `this` nastavit jako tracking referenci (napsat např. `ref this Point p`)
			- od určité verze C# to funguje klasickým voláním – není potřeba manuálně získat tracking referenci na proměnnou
	- s extension metodami to moc nepřehánět
- fyzikální simulace
	- máme čas v sekundách a vzdálenost v metrech, nechceme to přiřazovat napříč, řešením jsou opět struktury
	- chceme počítat minimum z několika hodnot v metrech
		- Math.Min nám vrátí double, pomocí extension metod a fluent syntaxe to převedeme na metry
- převod mezi Fraction a double
	- dávala by smysl implicitní konverze?
	- asi radši explicitní oběma směry
	- z Fraction na double by možná šla implicitní – holt očekáváme ztrátu přesnosti
- převod mezi Fraction a int
	- int → Fraction implicitně
	- Fraction → int explicitně
- operátory, indexery, vlastnosti a události se kompilují do normálních metod
	- `op_Implicit`
	- `op_Explicit`
	- `get_*`
	- `set_*`
- můžeme definovat overloading operátorů (sčítání, odčítání apod.)
- domácí úkol
	- fyzikální knihovna
	- co má umět?
	- fyzikální knihovna pro hru bude jiná než pro jaderné výbuchy
	- v TestConsoleApp/Program.cs je nějaká demonstrace
	- JumpingPlatformGame
		- windows forms
		- nemusíme se starat o UI
		- máme vzít Entities
			- dodat funkcionalitu, aby to umělo běhat doleva, doprava
		- kód v MainForm nemodifikovat (usingy můžeme upravovat)
			- to, co svítí červeně, tam typicky něco chybí
		- funkce RegisterEntity
		- funkce Update($\Delta s$)
			- odsimulovat, že uběhlo několik sekund – o ty je potřeba entity posunout vůči minule
		- nevadí, že simulace nebude absolutně přesná (např. z hlediska hranic obrazovky)
	- přímo ve winforms jsou nadefinované barevné čtverečky jako nějaké labels
		- neočekává se, že tam bude mnoho jezdících komponent
		- takhle se hry nedělají, tohle je jen pro jednoduchost
	- naklonovat projekt z gitlabu, vyrobit takové řešení, které funguje
	- nahrát do gitlabu, zaškrtnout v sisu
	- můžeme gitlab používat, jak jsme zvyklí
	- čas je do příštího cvičení
	- simulace už tam je naprogramovaná, jen tam chybí ta fyzikální knihovna
		- pohyb do stran, u některých postaviček skákání
		- pohyb i skákání je lineární, nesnažit se to přepsat
- interfaces
	- IIntValue – vyžaduje intovou vlastnost Value
	- IIncrementable – vyžaduje voidovou metodu Increment
- jak docílit, aby parametr implementoval oba interfacy?
	- jeden interface může dědit od druhého
	- nebo použiju generickou metodu
- pokud generickou metodu zavolám s hodnotovým parametrem, tak se neboxuje
	- to je kontrast vůči metodě s interfacovým parametrem – pokud je parametr struktura, tak se boxuje
- přetěžování metod nám pomůže, když chceme metodu volat s parametry různých typů (nebo interfaců)
	- když má metoda `f` dvě varianty pro parametr `IA` a `IB`, tak se náš kód nepřeloží, pokud nějaký typ implementuje oba interfacy
	- musíme přetypováním rozhodnout, kterou variantu chceme zvolit
- dají se takhle přetěžovat generické metody?
	- pokud bychom nechtěli boxovat struktury
	- `f<T>(T t) where T : IA`
	- `f<T>(T t) where T : IB`
	- v CIL kódu není informace o constraints, je to jenom v metadatech
	- takže tohle se nepřeloží :(
	- jak to ohackovat?
		- dáme metody do různých typů – jeden dědí od druhého (takže nový přidáme *nad* ten stávající)
		- ale takhle zakryjeme jednu z metod
		- takže to taky nefunguje
	- použijeme extension metodu!
		- ale to nefunguje úplně dokonale
		- pokud bychom chtěli další metodu, museli bychom vytvořit další třídu
		- problém máme taky s viditelností – nevidíme private věci
	- žádné lepší řešení zatím neznáme
- domácí úkol
	- nové zadání si stáhneme pomocí tlačítka Update Fork v GitLabu
	- chceme udělat něco lepšího než winforms ;)
	- Control je obecný prvek okénkového systému
	- chtěli bychom přidat Panel, který obsahuje několik Controls
	- Panel může obsahovat i Panel
	- úkol: přidat podporu pro dva druhy panelů
		- StackPanel obsahuje seznam (nebo prostě nějakou datovou strukturu) komponent, které jsou v něm
		- Canvas obsahuje kromě komponent i informace o jejich souřadnicích
	- chtěli bychom tyhle Controls vyrábět a používat pomocí fluent syntax
		- metody vracejí this – dají se hezky řetězit
		- `var image = new Image().WithUrl(…).WithZoom(…);`
		- with by v nás mohlo evokovat imutabilitu – ale tady to neplatí, vracíme přímo objekt samotný, ne jeho kopie
	- měli bychom dodržet formát výstupu – viz reference-output
	- chtěli bychom přidat fluent syntax podporu i pro panely
		- PlacedIn
		- mělo by být jedno, jestli se to tam nejdřív umístí a pak nastaví URL nebo naopak
		- u Canvasu se hned za PlacedIn musí volat At
			- pokud se místo At volá něco jiného, nemá to jít přeložit
			- pokud se pak už nic nevolá, tak to může jít přeložit, ale nemělo by se nic stát
	- nemusíme řešit překrývání apod.
	- deadline – do příštího týdne (společně s předchozím úkolem)

---

- domácí úkol na fyziku
	- jak pojmenovat typy?
	- asi lepší Meters než Distance, protože to stejně budeme ukládat v metrech
	- v dotnetu je typ TimeSpan
		- ale my v naší hře nepotřebujeme být tak obecní
	- mohlo by být vhodnější mít jednotky Pixel, Frame a PixelsPerFrame?
	- z hlediska času (i prostoru )je struktura zadarmo – počítání je stejně rychlé jako počítání přímo s doubly
	- jak napsat extension metody jednodušeji?
		- můžeme použít generické metody s omezením, aby to byl `IConvertible` a `INumber<T>`
		- pak máme trochu problém s charem, protože `'5'.Meters()` je vlastně 53 metrů
		- podobný problém může nastat u typu decimal, když tam uložíme 0.1
		- takže je asi lepší podporovat jenom int a double, protože to bylo v zadání
	- nejde nějak rozumně zobecnit operátory
		- ale to nevadí, tady duplikace kódu není problém – je ho málo a nebude se měnit
- domácí úkol s panely
	- kód uvnitř Canvasu a StackPanelu je hodně podobný
	- můžeme udělat abstraktní Panel
	- v Canvasu přidáme seznam souřadnic – seznam Controls je protected, takže můžeme předpokládat, že nikdo nebude měnit pořadí
	- název typu, který potřebujeme k ToString, můžeme uložit do abstraktní statické vlastnosti
		- asi radši ne public, protože pak by to lidi začali používat a my bychom to nemohli změnit
	- jak se zbavit overheadu?
		- pomocí generických typů
		- ale ty to zesložití
- domácí úkol
	- immutabilita je fajn
	- místo změny vytořím kopii se změnou
		- With
	- programujeme SIS
	- Person
		- Teacher
			- CoursesHeld
		- Student
			- DateEnrolled
	- všechno to má být immutable
	- pokud je to immutable, dost často potřebuju vytvářet instance
	- vlastně bych mohl mít nějakého defaultního studenta s výchozími hodnotami, je zbytečné ho alokovat pořád znova a znova
	- položky se mění po jedné – nedají se změnit dvě naráz
	- u recordů funguje klíčové slovo With – to ale nyní nebudeme používat ani bychom ho neměli analyzovat (může nás posunout špatným směrem)
	- dává smysl, aby to byly třídy (ne struktury)
	- pro jednoduchost je nám jedno, jaký typ vrací `justStudents.WithPasswordResetByFirstName`
		- ideální by bylo, kdyby to vracelo `List<Student>`
		- když nám to nepůjde, tak nevadí
	- typy udělat co nejvíc immutable to půjde
		- u vlastností dát init, private set nebo protected set (nejlepší je init)
- užitečné constraints pro generické typy
	- struct – hodnotový typ (kromě Nullable)
	- class – referenční typ
	- new() – má bezparametrický konstruktor
- řešení úkolu s immutable studenty
	- máme abstraktní Person
	- z něj vychází role Student, Teacher
		- rolí může být víc
	- vlastností Person i vlastností jednotlivých rolí může být víc
	- můžou být i nějací potomci Studenta apod.
	- co bude vracet WithName zavolaná na Studentovi?
		- musí vracet Studenta
	- při použití se nejdříve nastavují obecné hodnoty, až pak ta specifická
		- připomíná to builder pattern
			- budeme mít mutable builder, kterému postupně nastavujeme hodnoty → nakonec vytvoříme instanci Person
		- může být užitečné použít klíčové slovo required – uvnitř builderu máme k dispozici ale i silnější nástroje (třeba kontrolu toho, že nejsou zároveň nastaveny FirstName, LastName a FullName)
		- ale builder pattern neřeší náš problém s vracením specifického typu
			- PersonBuilder musí být generický
			- `PersonBuilder<TSelf> where TSelf : PersonBuilder<TSelf>`
				- taky se používá TConcreteSelf, TSpecific, apod.
			- uvnitř WithName musíme this explicitně přetypovat na TSelf – ale my víme, že PersonBuilder je abstraktní, takže to nevadí (pokud někdo nevytvoří divného potomka PersonBuilderu)
		- vyřešili jsme vracení specifického typu, ale builder neřeší náš problém
	- použijeme `Person<TSelf>`
		- musíme zajistit kopírování
		- takže použijeme constraint na `new()`
		- jak okopírovat data?
			- nejsem schopen požadovat specifický konstruktor
			- takže budu mít virtuální/abstraktní metodu Copy
			- ta bude brát jako parametry name a password
				- šlo by to i líp, ale zbavili bychom se extrémní immutability
		- do `Person<TSelf>` můžu dát statickou vlastnost Default (s výchozí hodnotou rovnou instanci TSelf)
	- musíme vytvořit ještě rodiče Person, od kterého bude dědit `Person<TSelf>`
		- Person musí mít WithName a WithPassword
		- můžeme to zajistit zakrýváním metod nebo pomocí virtuálních metod
	- `List<Student>` a `List<Person>` jsou invariantní
		- metoda PrintAll může být generická
		- nebo může mít parametr `IReadonlyList<Person>`, který je kovariantní
			- případně něco slabšího – klidně `IEnumerable<Person>`
- další domácí úkol
	- zadání úkolu na videu
	- vyrábíme knihovnu na práci s desetinnými čísly ve fixed point aritmetice
	- specifikuju pozici desetinné čárky
		- Q3.5 … 3 bity před desetinnou čárkou, 5 bitů za ní
	- používáme celočíselné operace procesoru (`+ - * /`)
	- chceme tam mít metodu ToDouble a taky hezkou metodu ToString, aby se to správně vypisovalo
	- konstruktory
		- pro double
		- pro celé číslo
	- generický typ Fixed
		- definujeme typ, kterým budeme čísla interně reprezentovat (byte, short, int, long)
		- definujeme počet bitů za desetinnou čárkou
			- zavedeme typy Dot3, Dot4, Dot8, Dot16, Dot24
			- nemusíme kontrolovat, že je za desetinnou čárkou nejvýš tolik bitů, kolik typ podporuje
	- nebudeme kontrolovat přetečení – vždycky provedeme truncation
	- chceme metodu To, která zajistí převod na jinou fixed-point reprezentaci
	- aby se na Listu vhodných typů (třeba i intů) dalo provést SumAll
		- můžou se nám hodit interfacy
			- viz interfacy pod IBinaryInteger (a INumberBase)
		- https://learn.microsoft.com/en-us/dotnet/standard/generics/math
		- můžou se nám hodit identity (AdditiveIdentity, MultiplicativeIdentity)
		- můžou se nám hodit factory metody Create uvnitř INumberBase
	- záporná čísla nemusíme řešit

---

- domácí úkol: u DotX typů bylo vhodné použít abstraktní statickou vlastnost (to od C# 11 umožňují interfacy, viz poznámky z přednášky)
- když chci vypsat položky pozpátku, tak raději použiju IReadOnlyList, protože při použití IEnumerable by to spotřebovalo O(n) paměti
- pozor, kovariance funguje jenom pro referenční typy
	- takže když máme metodu s parametrem typu `IEnumerable<object>`, tak jí nemůžeme předat seznam intů
	- řešením by byla generická metoda, ale pak by se pro každý odlišný list JITovala další metoda
		- ale to obvykle není problém
		- pro všechny referenční typy se JITuje jen jedna společná varianta, pro každý hodnotový typ se JITuje samostatná
- mohl by být IReadOnlyDictonary deklarován takto? `IReadOnlyDictionary<in TKey, out TValue>`
	- teoreticky mohl – indexer má `TKey` jako parametr, takže tam musí být `in` nebo nic
		- naopak vrací `TValue`, takže tam musí být `out` nebo nic
	- ale obsahuje `IEnumerable<TKey> Keys`, takže TKey musí být `out` nebo nic
	- zároveň typ implementuje interface `IEnumerable<KeyValuePair<TKey, TValue>>`
		- bylo by neefektivní KeyValuePair alokovat – takže je to struktura, což je hodnotový typ, takže tam žádná variance nefunguje
	- takže je IReadOnlyDictonary deklarován jako `IReadOnlyDictionary<TKey, TValue>`
- domácí úkol
	- imlementujeme validační framework
	- klient posílá požadavky na server
	- hlídáme, aby klient serveru neposílal blbosti
	- náš přístup
		- přijdou nám data k objednávce
		- nejdřív zavoláme `new Order()`
		- až pak `Order` validujeme pomocí metody `Validate`
		- dalo by se to dělat i naopak, ale tento přístup je jednodušší
	- validace může mít potenciálně více problémů
		- výstupem validace je seznam validačních chyb … `List<ValidationError>`
		- seznam bude prázdný, když tam není žádný problém
	- validátory
		- NonBlankStringValidator
		- rangeValidator
		- StringLengthValidator
		- NotNullValidator
			- pozor, textová reprezentace nullu v C# je `""`
	- ze základních validátorů skládáme uživatelský validátor
		- OrderValidator
			- jeho rozhraním je metoda Validate – je na nás, jak bude vypadat její hlavička
			- postupně budu validovat části Orderu
			- výsledkem validace je jeden List obsahující všechny validační chyby
				- použijeme metodu AddRange, která je na Listu
			- (asi uvnitř OrderValidatoru?) budeme potřebovat nějakou variantu metody ValidateAll, přičemž té metodě budeme moct předat více validátorů
				- použijeme [klíčové slovo `params`](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/method-parameters#params-modifier)
			- bylo by fajn, kdybych mohl SuperOrdery zvalidovat klasickým OrderValidatorem
				- v metodě ValidateSuperOrder
	- úkol má rozšíření, za které dostaneme bonusové body
		- AdvancedOrderValidator
		- vymyslet podobnou, ale kompaktnější syntaxi
			- můžou tam být jiné závorky apod.
			- chci se zbavit `new` a typových parametrů (pokud se dají odvodit)
