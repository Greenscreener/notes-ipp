# Pokročilé programování v C\#

- když lze přiřadit proměnnou typu A do proměnné typu B?
	- referenční typy
		- pokud jsou typy kompatibilní z hlediska hierarchie dědičnosti → implicitní konverze
	- hodnotové typy
		- existuje implicitní konverze int → long
			- provádí se sign extension
			- podobně pro ostatní celočíselné typy (směrem, kterým se zachovává hodnota)
		- existuje i implicitní konverze na float nebo double – tam se ztrácí přesnost
		- neexistují konverze s boolem
	- hodnotový → referenční
		- provede se (implicitní) boxovací konverze
	- referenční typy – explicitní konverze
		- máme proměnnou typu object, chceme ji (explicitní konverzí) přiřadit do typu string
			- `string s = (string) o;`
		- je potřeba ověřit, že typ objektu uvnitř proměnné typu object je string (nebo jeho potomek) – tedy jestli se dá přiřadit
		- provádí se runtime check, aby se zjistilo, že se dá přiřadit
		- když to nejde, vyhodí se InvalidCastException
	- int a long od sebe nijak nedědí, pouze mezi nimi existují konverze
	- long → int je potřeba konvertovat explicitně (můžou se ztratit data)
	- unboxovat je potřeba explicitně (nemusí to vždycky fungovat)
		- musím přesně napsat typ, který je uvnitř (tzn. zaboxovaný int se nedá unboxovat do longu)
- uvažujme třídu Fraction (klasický zlomek, má intový čitatel a jmenovatel)
	- chci umět se zlomky pracovat třeba pomocí Math.Sin(…) apod.
	- hodilo by se implementovat konverzi na double
		- to by šlo zajistit metodou ToDouble()
		- tam potřebujeme inty dělit reálně, takže použijeme operátor explicitní konverze k implicitní konverzi
		- `public double ToDouble() => ((double) a) / b;`
	- hodilo by se implementovat konverzi z double na Fraction
		- mohli bychom mít statickou metodu ToFraction, která vrátí Fraction
			- Fraction.ToFraction … opakuje se tam slovo
		- tak by tam mohl být konstruktor `public Fraction (double d)`
			- to není úplně ideální
		- dědičnost?
			- nesmysl
		- chtěli bychom double.ToFraction
			- tomu se říká fluent syntax
			- použijeme extension metody
			- nová syntaxe
			- připomínka klíčového slova params – umožňuje metody s proměnným počtem parametrů
			- `class X { public static void f(this A a, int b) {…} }`
			- dá se volat `X.f(a1, 5);`
			- ale díky `this` se dá taky volat `a1.f(5);`
				- to se za překladu vyhodnotí jako `X.f(a1, 5);`
			- `this` se dá napsat pouze před první parametr
			- kdyby existovala i třída Y se stejnou metodou f, tak by se `a1.f(5);` nepřeložilo
			- třída X musí být statická (tzn. tohle this se dá zapsat jen u statické metody uvnitř statické třídy)
				- to urychluje compile-time hledání vhodné metody
			- vhodná metoda se hledá jen uvnitř aktuálního jmenného prostoru (a uvnitř jmenných prostorů importovaných pomocí `using`)
			- pokud volám `a.f(…)`
				- nejdřív se hledá vhodná metoda na typu proměnné
				- pak se hledají extension metody v konkrétním namespacu
				- pak se hledají extension metody v dalších namespaces
			- třída X by se měla jmenovat StringExtensions
			- extension metody se dají volat i na potomcích (tzn. hledají se tranzitivně extension metody všech předků)
			- pokud třída neimplementuje interface IComparable, tak nám extension metoda CompareTo nepomůže
			- k čemu se hodí extension metody
				- externí typy
				- obrovský projekt a malý podprojekt (do velkého projektu nechci sahat a přidávat tam pomocné metody / zvětšovat rozhraní jednotlivých tříd)
				- umožňuje nám to implementovat fluent syntax

---

- method overloading
	- `m(int i)` a `m(long l)` spolu vůbec nesouvisí
	- v CIL kódu se objeví jako `m'int` a `m'long`
		- teda místo `int` tam bude `System.Int32` apod.
	- máme volání – za překladu se podle typu parametrů rozhodne, která metoda se bude volat
	- situace
		- metody v knihovně
		- volání v programu, který knihovnu používá
		- za překladu se určilo, že se volá `m'int`
		- ale v používané verzi knihovny je jenom `m'long`
		- JIT nutně zahlásí chybu – volaná metoda neexistuje
	- jak překladač vyhledává vhodný overload?
		- hledá v aktuálním kontextu
			- hledá se v kontextu metody a typu za překladu
			- tzn. mezi metodami, které jsou definované v daném typu
				- tudíž pokud se najde vhodná metoda definovaná uvnitř potomka, tak už se v předkovi nehledá
				- proč? kvůli tomu, že předek a potomek můžou být v různých assemblies (např. knihovna a hlavní program)
		- hledá podle arity
		- hledá nejspecifičtější overload + tak, aby to bylo nejméně práce
			- pokud mám metodu s overloady pro long, ValueType a object a volám ji pro int, tak se zavolá longová verze
			- dá se definovat uživatelská implicitní konverze
				- statická metoda `operator` v jednom z typů
				- parametr = zdrojový typ
				- název metody = cílový typ
				- lze zvolit, jestli je konverze implicitní nebo explicitní
				- způsob konverze probereme na cvičení
				- není dobré to s konverzemi přehánět
				- musí existovat jen jedna taková metoda – jinak překladač vyhodí chybu (ale až pokud chceme konverzi použít)
					- když bude jedna implicitní a druhá explicitní a pokusíme se provést explicitní konverzi, taky to vyhodí chybu (jelikož i implicitní konverzi lze volat explicitně)
			- když existuje (i uživatelsky definovaná) implicitní konverze na typ, pro který je definovaný overload, tak se použije ten (místo overloadu pro object)
			- dokonce to funguje i E2 –> E --> D –> A
				- kde –> je dědičnost
				- --> je uživatelská implicitní konverze
				- existuje overload pro A (ale pak už jen pro object)
				- pro proměnnou typu E2 se pustí overload pro A
			- ale vybírá se maximálně jedna uživatelská konverze
				- protože více konverzí vede ke zmatení
				- tedy na řetízku konverzí musí být maximálně jedna uživatelská, překladačových (implicitních hodnotových nebo dědičnostních) může být libovolně mnoho
			- zabudovaných konverzí se ale může vybrat víc
				- takže pokud na dané úrovni existuje jenom doublová varianta metody, tak se zavolá, pokud ji zavolám s parametrem typu char
				- protože existují implicitní konverze char → int → long → float → double
		- když se nic nenajde, tak se přesunu o kontext výš a opakuju kroky
	- situace
		- v předkovi A je metoda m(int)
		- v potomkovi B je metoda m(double)
		- chceme v potomkovi volat intový overload
		- ale `m(1);` volá `B.m(double);`
		- použijeme `((A) this).m(1);`
		- nemůžeme použít `base.m(1);`?
			- někdy ano, ale tohle vynucuje nevirtuální volání, což někdy nechceme
	- když se overloady (např. pro int a long) neliší jen typem, ale také sémantikou (třeba efektivitou apod.), tak je vhodné je pojmenovat různě
- generické metody
	- chceme metody `int Max(int, int)` a `long Max(long, long)`
	- mohli bychom je rozkopírovat, protože vlastně vypadají úplně stejně
	- ale *kopírování je častým zdrojem chyb*
	- mohli bychom mít `object Max(object, object)`?
		- hodnotové typy by se musely boxovat :(
		- co když funkci najednou předám int a double? co má vrátit?
	- použijeme generické metody!
	- `T Max<T>(T a, T b) { … }`
		- uvnitř můžeme používat typ `T` jako placeholder
		- metoda se používá jako `Max<int>(…);` apod.
		- v C# se dá použít `Max<>(…);`, ale to má velmi specifické použití
	- v C++
		- hlavičkový soubor
		- ve výsledném souboru nikdy není původní šablona
		- máme k dispozici jenom konkrétní specializace šablony, které jsme se rozhodli použít
	- v C# je myšlenka hlavičkových souborů nahrazena metadaty v assembly
	- generická metoda zůstává generickou na úrovni CIL kódu
		- tudíž CIL kód musí být dostatečně obecný – k tomu se dostaneme později
	- v CIL kódu volání bude výběr konkrétní specializace generické metody
	- JIT za run-timu vyrábí specializované varianty generické metody
	- konvence – placeholder typy obvykle začínají písmenem T
	- důležitá myšlenka – překladač si může vhodnou specializaci zvolit sám
		- takže napíšu `Max(…)` a překladač zvolí vhodnou specializaci automaticky
		- pokud má metoda např. tři parametry typů T1, T1, T2, tak překladač vlastně řeší rovnici
		- pokud se mi nelíbí automatická volba specializace a chci to ovlivnit, tak můžu přetypovat parametry – ale vhodnější je prostě definovat specializaci do špičatých závorek
	- generická metoda se dá kombinovat s konkrétními overloady
		- překladač zvolí overload pro konkrétní typy parametrů, pokud existuje
		- pokud neexistuje, typicky zvolí generickou metodu
	- situace – mám generickou metodu, která volá generickou metodu s konkrétními overloady
		- metoda `m` má generickou variantu, ale také variantu pro parametr typu double a pro object
		- `CallM<T>` je generická, uvnitř je volání `m(v)`, kde `v` je typu `T`
		- to se přeloží na volání `m<T>(v)`
		- konkrétní overloady se nikdy nezavolají, jelikož se za překladu musí určit, která jedna metoda se v rodičovské generické metodě bude volat
			- a generická `m` je prostě jediná vhodná – je použitelná pro všechna možná `T`
			- kdyby tam generická metoda nebyla, volal by se overload s parametrem object
		- tohle chování je jiné v C++
			- tam se za generický typ dosazuje při překladu
	- připomenutí
		- máme generickou metodu
		- za compile timu vznikne jeden CIL kód této metody
		- za run timu – jakmile se zavolá určitá (např. intová) varianta metody, JIT vygeneruje strojový kód pro danou variantu metody
	- v CIL kódu je zapsáno, jaká metoda se volá
		- zda je to nějaká specializace generické metody
		- nebo je to třeba nějaký z konkrétních overloadů metody
	- ve složitější typové hierarchii
		- generická metoda může být virtuální
		- dá se overridovat pouze generickou metodou (jinou implementací)
		- pokud v potomkovi zadefinuju negenerickou metodu s dosud neexistujícím typem (tedy overload) s `new`, tak je to `new` zbytečné, nic se nezakrývá
	- co můžeme dělat uvnitř generické metody s parametrem typu `T`?
		- můžeme volat metody objectu
	- připomenutí
		- v Pythonu duck typing
		- v C# compile-time duck typing u pattern matchingu (viz dekonstruktory)
		- v C++ compile-time duck typing u šablon (generických metod) – strojový kód jednotlivých specializací metod se generuje za compile timu
	- v C# se taky dá používat pythonovský duck-typing
		- vydáme na půdu materiálního vulgarismu – použijeme klíčové slovo `dynamic`
		- u proměnné s typem `dynamic` se zapne runtime duck typing
		- proměnná se přeloží jako typ object
		- ale dají se na ní volat libovolné metody
			- za runtimu se zjistí, jestli existují – pokud ne, tak se vyhodí chyba
	- u generických metod použijeme interfaces, abychom mohli volat něco jiného než metody objectu
		- `void m<T>(T a) where T : podmínky {}`
		- další where se píše na další řádek
		- tento způsob kontraktu je důležitý – i pro vývojáře daných metod (aby v další verzi něco nerozbili)
	- metoda s interfacovým parametrem vs. generická metoda s constraintem na daný interface
		- funguje to hodně podobně
		- rozdíl – interfaces u hodnotových typů
			- v metodě s interfacovým parametrem se bude hodnotový typ boxovat
			- v generické metodě se nic boxovat nebude, navíc se strojový kód vygeneruje přímo pro danou hodnotu (respektive pro daný typ) včetně všech optimalizací
		- ale typicky dává smysl preferovat klasickou metodu s interfacovým parametrem
		- JIT umí pro referenční typy recyklovat strojový kód
			- pro (různé) hodnotové typy to vždycky generuje nový strojový kód
		- u generických metod typicky chceme používat type inference (automatické generování špičatých závorek u volání) – to může komplikovat práci překladači (?)
	- další použití
		- generická rozhraní (interfaces) – např. `IComparable<T>`
		- extension metody
			- `public static T[] Slice<T>(this T[] source, …) { … }`
			- s generickými extension metodami je potřeba šetřit (a psát jasné constraints)
- generické typy
	- může to být třída, struktura, interface
	- syntaxe podobná jako u metod – také s constraints
	- za compile timu se generuje jeden CIL kód generického typu
	- za runtimu JIT generuje typy jednotlivých specializací
	- strojový kód metod se klasicky JITuje až při prvním volání
	- každá specializace má svůj vlastní class constructor a své vlastní statické fieldy
	- dědičnost
		- specializace generických typů jsou z hlediska stromu dědičnosti na stejné úrovni (nevedou mezi nimi hrany)
		- generická třída může dědit od negenerické třídy nebo od generické třídy, kde její specializace může být daná nebo může odpovídat specializaci potomka
	- v generické třídě můžou být metody…
		- negenerické s určenými typy parametrů
		- negenerické s typy parametrů odpovídajícími specializaci generické třídy (tedy `T`)
		- generické (s typy parametrů nezávislých na specializaci generické třídy)
		- → překladač vždy vybere nejspecifičtější variantu
			- když má na výběr mezi negenerickou s určeným typem a negenerickou s typem T, tak vybere tu s určeným typem
			- `m(T t)`, kde `T` je `int` vs. `m(int i)` → vyhraje `m(int i)`
	- u constraints se dá použít čárka, ta znamená AND
		- OR by nemělo smysl
	- lze mít více generických typů s různými constraints
	- generické fieldy nejsou, ale můžu mít field typu T v generické třídě
- interfaces
	- metoda interfacu se dá implementovat zděděním (rodičovská metoda má metodu, kterou vynucuje interface)
	- jedna metoda může zároveň naplňovat více kontraktů (když třída implementuje víc interfaců a všechny požadují jednu metodu, např. `Close`)
		- interfaces: `IReader`, `IWriter`
		- metoda v obou interfaces se jmenuje `Close`
	- je potřeba rozmyslet, kdo volá `Close` (nebo `Dispose`) – kdo daný zdroj drží (a kdo je zodpovědný za jeho uzavření/uvolnění)
	- u TCP protokolu dává smysl mít dvě různé implementace `Close`
		- chceme mít oddělené zavření pro čtení a pro zápis
		- můžeme to poskládat pomocí dědičnosti – Reader implementuje IReader, Writer je potomkem Readera, zakrývá Close, implementuje IWriter, ReaderWriter je potomkem Writera, jeho Close zavolá obě varianty
		- ale je to hrozně složité řešení
- explicitní implementace metody z interfacu
	- syntaxe
		- neuvedu viditelnost, za ni napíšu návratový typ, před jméno metody napíšu jméno interfacu, od názvu metody oddělím tečkou
		- https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/how-to-explicitly-implement-interface-members
	- takhle implementovanou metodu nemůžu zavolat přímo na daném typu, musím použít typ interfacu
	- takový přístup používá System.Int32, který implementuje interface IConvertible, ale interfacové metody to má implementované explicitně, takže se uživatelům běžně nezobrazují jako součást rozhraní
- generické typy v kombinaci s interfaces
	- situace z prezentace
	- nepřeloží se
- implementace generických interfaces
	- také v prezentaci
- this
	- v metodách máme implicitní parametr this
	- to platí i pro metody v interfacech
	- metody v interfacech musí být instanční, jinak by nebylo jasné, co bude this
- nová funkce C# – statické abstraktní metody v interfacech
	- je nezbytné je implementovat statickou metodou
	- k čemu je to užitečné?
	- když máme generický typ a chceme volat jeho statickou metodu
	- nově se u instančních metod v interfacu dá psát abstract (ale je lepší to tam nepsat)
	- funguje to i pro method-like věci (třeba vlastnosti)
	- do interfacu se dá zapsat defaultní implementace
		- this dává smysl používat jenom v instančních metodách
		- co když chci odkazovat na typ implementátora
			- použiju `TSelf`
			- `interface I1<TSelf> where TSelf : I1<TSelf> { … }`
			- kdy se tohle používá?
				- kdybych chtěl implementovat komplexní čísla s (generickým typem) volitelnou přesností
				- problém by nastal např. při implementaci sčítání
				- nově v C# existují interfaces, které nám tohle umožňují – mají implementovány potřebné operátory
- speciální constrainty
	- constraint na hodnotové typy `where T : struct`
	- constraint na referenční typy `where T : class`
- `C<object>` a `C<string>` mezi sebou nemají žádnou vazbu – nijak od sebe nedědí
	- bylo by hezké, kdyby se `List<string>` dal použít jako `List<object>`, protože všechny stringy jsou potomky objectu
	- pojmy
		- $(\alpha)$ typ B je typově kompatibilní s A
			- typicky pokud B dědí od A
			- takže instance B se dá přiřadit do proměnné typu A
		- $(\beta)$ typ C je parametrizovaný T a `C<B>` je typově kompatibilní s `C<A>`
			- C je kovariantní podle T
		- $(\gamma)$ typ C je parametrizovaný T a `C<A>` je typově kompatibilní s `C<B>`
			- C je kontravariantní podle T
		- $(\delta)$ třetí varianta kompatibility `C<A>` a `C<B>`
			- C je invariantní dle T
	- generické typy jsou invariantní (??)
	- pole referenčních typů jsou kovariantní
	- pole hodnotových typů jsou invariantní
	- každý zápis do každého pole referenčních typů vede na runtime check
		- kdybych měl pole stringů
		- to přiřadil do proměnné typu pole objectů
		- a pak do prvku přiřadil int
		- tak by to bylo blbě, protože bych do pole stringů přiřadil int
		- i když kovarianci nepoužívám, check se provádí
	- kovariance
		- getter je v pohodě
		- setter je problém
	- kontravariance
		- setter je v pohodě
		- getter je problém
	- typ nemůže být zároveň kovariantní i kontravariantní
	- pro jiné typy než pole se dá zapnout variance – ukážeme si příště
	- od C# 9 jsou virtuální metody kovariantní dle návratové hodnoty
		- v overridu metody můžu vracet „lepší“ typ, než který vracela původně
		- ale tohle zase funguje jenom u referenčních typů
			- protože by si navrácené hodnoty neodpovídaly velikostně ani sémanticky (reference na haldu vs. číslo apod.)
	- kovariance u polí
		- někdy na škodu – musíme provádět runtime check
		- někdy užitečná – můžeme psát univerzálnější kód
	- specializace Listu jsou invariantní
		- takže do parametru typu `List<object>` nemůžeme předat `List<Person>`
	- parametr `List<object>` je zbytečně specifický, stačí nám vlastnost `Count` a možnost indexace
		- mohli bychom použít interface `IList<object>`
		- takže můžeme jako parametr použít pole objectů
	- generické interfacy u referenčních typů jsou volitelně variantní
		- `interface I<T>` je invariantní dle T
		- `interface I<out T>` je kovariantní dle T
			- funguje jako výstupní typ metody
		- `interface I<in T>` je kontravariantní dle T
			- funguje jako vstupní typ metody
		- pro každý typový parametr je to nezávislé
		- příklad
			- `interface I<out T1, T2, in T3, in T4>`
			- `I<A,B,C,D> i = X : I<E,F,G,H>`
				- E dědí od A
				- B = F
				- C dědí od G
				- D dědí od H
			- tady je to správně, v přednášce chybně, viz errata dokument
		- nestačí implicitní konverze – musí to být podle typového systému
		- neprovádějí se runtime checky, prostě se zakáže špatné použití
	- `IList<T>` musí být zjevně invariantní, protože indexer vyžaduje getter a setter – tudíž musí být jako vstupní i výstupní typ
	- existuje `IReadonlyList<out T>`, kde indexer vyžaduje jenom getter
	- máme List stringů, chceme ho přiřadit do `IList<object>`, to nejde
		- překladač nám poradí použít cast
		- s castem se to přeloží, ale runtime check selže
	- obecně se dá castovat typ do interfacu, který neimplementuje, jen se provádí runtime check, jestli konkrétní objekt (jeho typ) implementuje daný interface
		- v proměnné typu A mám instanci typu B
		- B dědí od A
		- typ A neimplementuje interface I, ale typ B ho implementuje
		- můžu tu proměnnou explicitně castnout na interface I
		- kdyby typ A byl sealed, tak by se nám cast na interface, který neimplementuje, ani nepřeložil
	- `interface IComparer<in T>`
		- `int Compare(T a, T b)`
		- kontravariantní
		- máme metodu s argumentem typu `IComparer<B>`
			- `B` je potomkem `A`
			- takové metodě můžeme předat argument typu `IComparer<A>`
	- kovarianci použijeme, když budeme chtít mít pro zvíře jeden logger
		- pro vlka chceme mít speciální logger uložený ve stejné proměnné
- interfacy kolekcí
	- dává smysl používat generické varianty – ty negenerické jsou tam kvůli zpětné kompatibilitě
	- IList má oproti ICollection navíc indexer
	- IEnumerable
		- kdyby IEnumerable měl vlastnost Current a metody MoveNext a Reset
			- seznam by byl immutable
			- ale backing field vlastnosti Current by byl mutable
			- takže by ten typ nebyl immutable jako celek
			- to je nepraktické při vícevláknovém programování
		- návrhový vzor iterátor
			- v dotnetu `IEnumerator<out T>`
			- dostaneme ho pomocí metody GetEnumerator
			- pak z každého vlákna můžeme kolekci procházet nezávisle
		- z dotnetu 1 je tam negenerický typ IEnumerable
			- vlastnost Current v negenerickém interfacu IEnumerator je typu object
			- takže při implementaci IEnumerable musíme implementovat obě metody GetEnumerator
			- a taky musíme implementovat oba iterátory
		- na `IEnumerable` spoléhá implementace foreach cyklu
		- metoda Reset je často k ničemu
			- mnoho iterátorů ji nemá
			- místo ní hážou výjimku (not implemented)
			- když budu implementovat iterátor, je lepší ho tam mít
			- když budu používat nějaký obecný iterátor, je lepší Reset nevolat – radši získat nový iterátor

---

- namespaces (jmenné prostory)
	- můžu je vnořovat – je to syntaktická zkratka
	- tečka je v dotnetu validní součást identifikátoru
		- překladač vidí jenom názvy typů jako celek (i s tečkami)
	- v názvu jmenného prostoru může být tečka
		- takže namespace A.C je stejný jako namespace C uvnitř namespace A
	- jmenné prostory jsou z pohledu CLR ploché – zanoření nemá žádný speciální význam
	- když použijeme using, tak se aktivují extension metody daného jmenného prostoru
- nested types (vnořené typy)
	- z pohledu CLR jsou typy opravdu vnořené (na rozdíl od namespaces)
	- mějme namespace X, v něm typ A, uvnitř vnořený typ B
	- konvence CLI pro názvy vnořených typů (pro výpis)
		- X.A+B
	- konvence C# pro názvy vnořených typů (pro použití v kódu)
		- X.A.B
	- k čemu je to užitečné?
		- v Javě je souvislost mezi instancemi A a B
			- uděláme instanci A
			- v kontextu A vyrobíme B
			- to B má zpětně referenci na instanci A
			- v C# tohle neplatí
		- v C# můžu lépe upravovat viditelnost typů
			- normální typy můžou mít viditelnost internal, public nebo file
			- vnořené typy můžou být private, protected, public, internal, …
			- docela častá je viditelnost private – daný typ vidí jenom kód uvnitř A
			- kdyby A byl SortedDictionary implementovaný červeno-černým stromem, tak potřebuju nějaký typ, který bude reprezentovat vrchol toho stromu
				- je to implementační detail, takže je vhodné, aby typ Node byl vnořený – takže nehrozí, aby ho začal používat někdo jiný
	- když máme metodu v internal interface a nějaká třída ji implementuje jako interfacovou, tak se bez přístupu k interfacu ta metoda nedá zavolat
		- metoda by taky mohla být interní a výsledek by byl stejný, ale to teď není důležité
		- podobně můžeme mít v nějakém typu vnořený private interface a použít podobný efekt u vnořeného typu, který ten interface implementuje
	- vnořený typ má přístup k private věcem nadřazeného typu
	- vnořený typ může dědit od nadřazeného typu
- `IEnumerable`
	- dává smysl Enumerator mít jako privátní vnořenou třídu
	- jak se enumerátor chová
		- kolekce o 0 prvcích
			- pokud zavoláme getter vlastnosti .Current před spuštěním, vyhodí to InvalidOperationException
			- pokud zavoláme .MoveNext() u prázdné kolekce, vrátí to false
			- když potom zavoláme .Current, vyhodí to InvalidOperationException
		- kolekce o 1 prvku
			- .Current → InvalidOperationException
			- .MoveNext() → true
			- .Current → 1. prvek
			- .Current → 1. prvek
			- .MoveNext() → false
			- .Current → InvalidOperationException
		- enumerátor má tři stavy – před kolekcí, uvnitř kolekce, za kolekcí
		- metoda Reset by nás z libovolného stavu měla vrátit do stavu před kolekcí – ale často nebývá implementována
		- proč má enumerátor stav „před kolekcí“? aby podporoval prázdné kolekce
	- kdyby pro nás bylo důležité, kolik má kolekce prvků, použijeme ICollection s vlastností Count
	- nikdo nás nenutí projít IEnumerable celé, nikdo nás nenutí číst prvky (třeba nás jenom zajímá, jestli kolekce obsahuje nějaký prvek → jednou použijeme MoveNext)
	- v pokročilejších frameworcích může být uvnitř enumerátoru drženo spojení do databáze nebo nějaké cenné zdroje
		- IEnumerable rozšiřuje IDisposable
		- takže pokud používám enumerátor, měl bych nakonec zavolat Dispose
	- můžu vyrábět nekonečné kolekce – např. sekvenční generátor náhodných čísel
		- pokud potřebuju konečnou kolekci, použiju ICollection
	- concurrent modification
		- během používání enumerátoru modifikuju kolekci
		- může mi vzniknout race condition
		- tedy kolekce IEnumerable typicky nepodporují concurrent modification, může se vyhodit InvalidOperationException
		- problém je, když se modifikace provede mezi dvěma použitími jednoho enumerátoru
		- bug není v tom, že já modifikuju kolekci (pokud je třeba IList)
			- bug je v tom, že mi někdo dal moc velká práva ke kolekci
			- takže výjimka by měla být vyhozena z MoveNext
				- kolekce si může evidovat verze
				- enumerátor si může evidovat verzi, ze které vznikl
				- při volání MoveNext se porovná verze
	- foreach
		- generuje while cyklus
		- překladač…
			- nejdříve zkusí, jestli se na typu dá zavolat GetEnumerator
				- můžeme ji dodat i pomocí extension metody
				- tohle je vlastně duck-typing
			- pak zkouší, jestli typ implementuje generický interface
			- nakonec zkouší, jestli typ implementuje negenerický interface
			- na nalezený interface to přetypuje
		- dá se použít type inference (var)
		- pokud použijeme konkrétní typ, tak se návratová hodnota Current explicitně přetypuje na daný typ
- jak pracovat s IList?
	- použít foreach nebo for cyklus?
	- při každém použití foreach se vytváří nový enumerátor
		- ale u polí se foreach překládá efektivněji – do for cyklu
			- pokud je za překladu jasné, že to bude pole
		- dává smysl, aby enumerátor byla struktura?
			- ale IEnumerable je interface, takže se enumerátor bude boxovat
			- no ale mohli bychom ve veřejné metodě GetEnumerator vracet strukturu
				- tím pádem musíme typ enumerátoru zveřejnit, aby se dal používat
				- tohle pak bude fungovat i s foreach cyklem
		- pokud překladač o typu ví jen to, že implementuje interface, tak na něm volá interfacovou metodu
- programujeme enumerátor
	- máme třídu A, tam jsou dvě pole x1, x2, ale ta se mají tvářit jako jedno
		- kdybychom chtěli dělat PrintAll, pomocí for cyklu bychom přeiterovali přes obě pole – prolíná se algoritmus pro výpis a pro iteraci
	- v enumerátoru budeme mít uložený stav procházení
		- v jaké fázi jsme (které ze dvou polí zrovna procházíme)
		- v kolikátém jsme prvku
	- je vlastně docela těžké tvořit enumerátory
	- v C# je koncept iterátorových metod
		- pokud metoda vrací IEnumerator a obsahuje `yield return`, zcela se změní způsob jejího překladu
		- metoda se podle yield returnů rozseká na jednotlivé kroky
		- první krok – od začátku metody do návratové hodnoty yield returnu (včetně)
		- druhý krok – od středníku za yield returnem do dalšího yield returnu
		- poslední krok – od středníku za posledním yield returnem do konce metody
		- návratová hodnota yield return se někam uloží, takže volání getteru vlastnosti Current vrací přímo hodnotu (už ji znova nepočítá)
		- neplatná volání Current jsou v rozporu s typickým kontraktem enumerátoru
			- volání getteru Current před prvním MoveNext vrací defaultní hodnotu `default(T)`
			- get_Current po posledním MoveNext vrací poslední hodnotu
		- náš kód skončí uvnitř enumerátoru
		- v těle naší metody nezůstane náš kód, ale bude tam vyrobení a vrácení toho enumerátoru
		- lokální proměnné z našeho kódu budou uloženy jako fieldy enumerátoru
			- platí to pro všechny lokální proměnné
			- v Release režimu si překladač všimne, že některé lokální proměnné není třeba držet globálně a přeloží je jako lokální (ne jako fieldy)
		- parametry naší iterátorové metody se taky uloží do enumerátoru (respektive jejich hodnoty se tam uloží – „capture by value“)
		- pokud je iterátorová metoda instanční metoda nějakého objektu, tak v ní můžu použít vlastnosti toho objektu (protože má implicitní parametr this)
			- pak se musí `this` nakopírovat (capture by value) dovnitř enumerátoru
		- náš kód se přeloží do stavového automatu (metoda MoveNext funguje jako stavový automat)
			- `_state`
				- na začátku ve stavu 0
				- při běhu se nastaví na -1
					- až na konci se nastaví na další validní stav
					- tím způsobem se ošetřuje situace, kdy se při běhu MoveNext vyhodí výjimka – mohlo dojít k poškození vnitřního stavu enumerátoru, takže se prostě skončí
				- -1 je koncový stav
			- sdílený kód jednotlivých stavů se sdílí pomocí goto
		- můžeme používat `yield break` – to je okamžitý přechod do koncového stavu
		- enumerátor podporuje lazy evaluation
			- iterátorové metody taky – s každým voláním MoveNext se provede jenom jeden krok
	- chci IEnumerable převést na List
		- lazy evaluation se dá převést na eager evaluation
		- konstruktor Listu má overload `new List<T>(IEnumerable<T>)`
		- někdy se to hodí, někdy to není dobrý nápad
			- třeba pokud potřebuju jenom první tři položky, tak není vhodné převádět celou kolekci na seznam, když má milion položek
			- ale pokud se při každém MoveNext něco stahuje ze sítě a chci přes kolekci iterovat víckrát, tak dává smysl si ji někam uložit pomocí eager evaluace
				- v System.LINQ jsou k tomu metody ToList a ToArray pro IEnumerable
				- trochu efektivnější je ToList, protože ToArray se pak musí kopírovat do pole, jelikož LINQ předem nezná délku IEnumerable
					- ale pokud je daná věc zároveň IReadOnlyCollection a tedy má Count, tak ho LINQ použije
- LinkedList
	- veřejná třída LinkedListNode – jednotlivé krabičky s hodnotami, aby se dalo přidávat před ně, za ně apod.
	- `LinkedList<T>` implementuje `IEnumerable<T>`
	- bylo by hezké, kdyby se dalo enumerovat přes krabičky v LinkedListu
		- `LinkedList<T>` by mohl implementovat `IEnumerable<LinkedListNode<T>>`, ale pak by se ten enumerátor složitěji používal
		- takže přidáme extension metodu `AsNodeEnumerable`
			- můžeme použít iterátorovou metodu
	- `x = new A {1,2,3};` je syntaktická zkratka za `x = new A(); x.Add(1); x.Add(2); x.Add(3).`
		- používá se compile-time ducktyping
		- Add se dá doplnit jako extension metoda
	- LinkedListNode
		- vlastnost Value s getterem a setterem
		- vlastnost RefValue vrací referenci přímo na hodnotu (má jenom getter), takže může zefektivnit práci s hodnotami uvnitř LinkedListu
	- přidáváme krabičky uvnitř foreache za aktuální krabičku
		- pokud budeme enumerovat lazy evaluací přes LinkedList, tak se to zacyklí
			- protože enumerátor typicky nepodporuje concurrent modification
		- pokud LinkedList převedeme pomocí eager evaluace na List, tak se to nezacyklí, ale zabere to dost paměti
		- nejefektivnější varianta bude taková, že budeme prvek přidávat za minulou krabičku
