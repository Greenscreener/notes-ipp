# Pokročilé programování v C\#

- když lze přiřadit proměnnou typu A do proměnné typu B?
	- referenční typy
		- pokud jsou typy kompatibilní z hlediska hierarchie dědičnosti → implicitní konverze
	- hodnotové typy
		- existuje implicitní konverze int → long
			- provádí se sign extension
			- podobně pro ostatní celočíselné typy (směrem, kterým se zachovává hodnota)
		- existuje i implicitní konverze na float nebo double – tam se ztrácí přesnost
		- neexistují konverze s boolem
	- hodnotový → referenční
		- provede se (implicitní) boxovací konverze
	- referenční typy – explicitní konverze
		- máme proměnnou typu object, chceme ji (explicitní konverzí) přiřadit do typu string
			- `string s = (string) o;`
		- je potřeba ověřit, že typ objektu uvnitř proměnné typu object je string (nebo jeho potomek) – tedy jestli se dá přiřadit
		- provádí se runtime check, aby se zjistilo, že se dá přiřadit
		- když to nejde, vyhodí se InvalidCastException
	- int a long od sebe nijak nedědí, pouze mezi nimi existují konverze
	- long → int je potřeba konvertovat explicitně (můžou se ztratit data)
	- unboxovat je potřeba explicitně (nemusí to vždycky fungovat)
		- musím přesně napsat typ, který je uvnitř (tzn. zaboxovaný int se nedá unboxovat do longu)
- uvažujme třídu Fraction (klasický zlomek, má intový čitatel a jmenovatel)
	- chci umět se zlomky pracovat třeba pomocí Math.Sin(…) apod.
	- hodilo by se implementovat konverzi na double
		- to by šlo zajistit metodou ToDouble()
		- tam potřebujeme inty dělit reálně, takže použijeme operátor explicitní konverze k implicitní konverzi
		- `public double ToDouble() => ((double) a) / b;`
	- hodilo by se implementovat konverzi z double na Fraction
		- mohli bychom mít statickou metodu ToFraction, která vrátí Fraction
			- Fraction.ToFraction … opakuje se tam slovo
		- tak by tam mohl být konstruktor `public Fraction (double d)`
			- to není úplně ideální
		- dědičnost?
			- nesmysl
		- chtěli bychom double.ToFraction
			- tomu se říká fluent syntax
			- použijeme extension metody
			- nová syntaxe
			- připomínka klíčového slova params – umožňuje metody s proměnným počtem parametrů
			- `class X { public static void f(this A a, int b) {…} }`
			- dá se volat `X.f(a1, 5);`
			- ale díky `this` se dá taky volat `a1.f(5);`
				- to se za překladu vyhodnotí jako `X.f(a1, 5);`
			- `this` se dá napsat pouze před první parametr
			- kdyby existovala i třída Y se stejnou metodou f, tak by se `a1.f(5);` nepřeložilo
			- třída X musí být statická (tzn. tohle this se dá zapsat jen u statické metody uvnitř statické třídy)
				- to urychluje compile-time hledání vhodné metody
			- vhodná metoda se hledá jen uvnitř aktuálního jmenného prostoru (a uvnitř jmenných prostorů importovaných pomocí `using`)
			- pokud volám `a.f(…)`
				- nejdřív se hledá vhodná metoda na typu proměnné
				- pak se hledají extension metody v konkrétním namespacu
				- pak se hledají extension metody v dalších namespaces
			- třída X by se měla jmenovat StringExtensions
			- extension metody se dají volat i na potomcích (tzn. hledají se tranzitivně extension metody všech předků)
			- pokud třída neimplementuje interface IComparable, tak nám extension metoda CompareTo nepomůže
			- k čemu se hodí extension metody
				- externí typy
				- obrovský projekt a malý podprojekt (do velkého projektu nechci sahat a přidávat tam pomocné metody / zvětšovat rozhraní jednotlivých tříd)
				- umožňuje nám to implementovat fluent syntax

---

- method overloading
	- `m(int i)` a `m(long l)` spolu vůbec nesouvisí
	- v CIL kódu se objeví jako `m'int` a `m'long`
		- teda místo `int` tam bude `System.Int32` apod.
	- máme volání – za překladu se podle typu parametrů rozhodne, která metoda se bude volat
	- situace
		- metody v knihovně
		- volání v programu, který knihovnu používá
		- za překladu se určilo, že se volá `m'int`
		- ale v používané verzi knihovny je jenom `m'long`
		- JIT nutně zahlásí chybu – volaná metoda neexistuje
	- jak překladač vyhledává vhodný overload?
		- hledá v aktuálním kontextu
			- hledá se v kontextu metody a typu za překladu
			- tzn. mezi metodami, které jsou definované v daném typu
				- tudíž pokud se najde vhodná metoda definovaná uvnitř potomka, tak už se v předkovi nehledá
				- proč? kvůli tomu, že předek a potomek můžou být v různých assemblies (např. knihovna a hlavní program)
		- hledá podle arity
		- hledá nejspecifičtější overload + tak, aby to bylo nejméně práce
			- pokud mám metodu s overloady pro long, ValueType a object a volám ji pro int, tak se zavolá longová verze
			- dá se definovat uživatelská implicitní konverze
				- statická metoda `operator` v jednom z typů
				- parametr = zdrojový typ
				- název metody = cílový typ
				- lze zvolit, jestli je konverze implicitní nebo explicitní
				- způsob konverze probereme na cvičení
				- není dobré to s konverzemi přehánět
			- když existuje (i uživatelsky definovaná) implicitní konverze na typ, pro který je definovaný overload, tak se použije ten (místo overloadu pro object)
			- dokonce to funguje i E2 –> E --> D –> A
				- kde –> je dědičnost
				- --> je uživatelská implicitní konverze
				- existuje overload pro A (ale pak už jen pro object)
				- pro proměnnou typu E2 se pustí overload pro A
			- ale vybírá se maximálně jedna uživatelská konverze
				- protože více konverzí vede ke zmatení
		- když se nic nenajde, tak se přesunu o kontext výš a opakuju kroky
	- situace
		- v předkovi A je metoda m(int)
		- v potomkovi B je metoda m(double)
		- chceme v potomkovi volat intový overload
		- ale `m(1);` volá `B.m(double);`
		- použijeme `((A) this).m(1);`
		- nemůžeme použít `base.m(1);`?
			- někdy ano, ale tohle vynucuje nevirtuální volání, což někdy nechceme
	- když se overloady (např. pro int a long) neliší jen typem, ale také sémantikou (třeba efektivitou apod.), tak je vhodné je pojmenovat různě
